{"version":3,"file":"static/js/395.014040ae.chunk.js","mappings":"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","sources":["../node_modules/music-metadata/lib/flac/FlacParser.js","../node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js","../node_modules/music-metadata/lib/ogg/vorbis/VorbisStream.js","../node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js","../node_modules/music-metadata/lib/flac/FlacToken.js","../node_modules/music-metadata/lib/ogg/opus/Opus.js","../node_modules/music-metadata/lib/ogg/opus/OpusStream.js","../node_modules/music-metadata/lib/ogg/speex/Speex.js","../node_modules/music-metadata/lib/ogg/speex/SpeexStream.js","../node_modules/music-metadata/lib/ogg/theora/Theora.js","../node_modules/music-metadata/lib/ogg/theora/TheoraStream.js","../node_modules/music-metadata/lib/ogg/OggToken.js","../node_modules/music-metadata/lib/ogg/flac/FlacStream.js","../node_modules/music-metadata/lib/ogg/OggParser.js","../node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js"],"sourcesContent":["import initDebug from 'debug';\nimport { Uint8ArrayType } from 'token-types';\nimport { VorbisPictureToken } from '../ogg/vorbis/Vorbis.js';\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { VorbisStream } from '../ogg/vorbis/VorbisStream.js';\nimport { VorbisDecoder } from '../ogg/vorbis/VorbisDecoder.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport * as Flac from './FlacToken.js';\nconst debug = initDebug('music-metadata:parser:FLAC');\nclass FlacContentError extends makeUnexpectedFileContentError('FLAC') {\n}\nexport class FlacParser extends AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.vorbisParser = new VorbisStream(this.metadata, this.options);\n        this.padding = 0;\n    }\n    async postId3v2Parse() {\n        const fourCC = await this.tokenizer.readToken(FourCcToken);\n        if (fourCC.toString() !== 'fLaC') {\n            throw new FlacContentError('Invalid FLAC preamble');\n        }\n        let blockHeader;\n        do {\n            // Read block header\n            blockHeader = await this.tokenizer.readToken(Flac.BlockHeader);\n            // Parse block data\n            await this.parseDataBlock(blockHeader);\n        } while (!blockHeader.lastBlock);\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n        }\n    }\n    async parseDataBlock(blockHeader) {\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n        switch (blockHeader.type) {\n            case Flac.BlockType.STREAMINFO:\n                return this.readBlockStreamInfo(blockHeader.length);\n            case Flac.BlockType.PADDING:\n                this.padding += blockHeader.length;\n                break;\n            case Flac.BlockType.APPLICATION:\n                break;\n            case Flac.BlockType.SEEKTABLE:\n                break;\n            case Flac.BlockType.VORBIS_COMMENT:\n                return this.readComment(blockHeader.length);\n            case Flac.BlockType.CUESHEET:\n                break;\n            case Flac.BlockType.PICTURE:\n                await this.parsePicture(blockHeader.length);\n                return;\n            default:\n                this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);\n        }\n        // Ignore data block\n        return this.tokenizer.ignore(blockHeader.length).then();\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    async readBlockStreamInfo(dataLen) {\n        if (dataLen !== Flac.BlockStreamInfo.len)\n            throw new FlacContentError('Unexpected block-stream-info length');\n        const streamInfo = await this.tokenizer.readToken(Flac.BlockStreamInfo);\n        this.metadata.setFormat('container', 'FLAC');\n        this.processsStreamInfo(streamInfo);\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    processsStreamInfo(streamInfo) {\n        this.metadata.setFormat('codec', 'FLAC');\n        this.metadata.setFormat('hasAudio', true);\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n        if (streamInfo.totalSamples > 0) {\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n        }\n    }\n    /**\n     * Read VORBIS_COMMENT from tokenizer\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async readComment(dataLen) {\n        const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));\n        return this.parseComment(data);\n    }\n    /**\n     * Parse VORBIS_COMMENT\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async parseComment(data) {\n        const decoder = new VorbisDecoder(data, 0);\n        const vendor = decoder.readStringUtf8();\n        if (vendor.length > 0) {\n            this.metadata.setFormat('tool', vendor);\n        }\n        const commentListLength = decoder.readInt32();\n        const tags = new Array(commentListLength);\n        for (let i = 0; i < commentListLength; i++) {\n            tags[i] = decoder.parseUserComment();\n        }\n        await Promise.all(tags.map(tag => {\n            if (tag.key === 'ENCODER') {\n                this.metadata.setFormat('tool', tag.value);\n            }\n            return this.addTag(tag.key, tag.value);\n        }));\n    }\n    async parsePicture(dataLen) {\n        if (this.options.skipCovers) {\n            return this.tokenizer.ignore(dataLen);\n        }\n        return this.addPictureTag(await this.tokenizer.readToken(new VorbisPictureToken(dataLen)));\n    }\n    addPictureTag(picture) {\n        return this.addTag('METADATA_BLOCK_PICTURE', picture);\n    }\n    addTag(id, value) {\n        return this.vorbisParser.addTag(id, value);\n    }\n}\n","import * as Token from 'token-types';\nimport { textDecode } from '@borewit/text-codec';\nexport class VorbisDecoder {\n    constructor(data, offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n    readInt32() {\n        const value = Token.UINT32_LE.get(this.data, this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readStringUtf8() {\n        const len = this.readInt32();\n        const value = textDecode(this.data.subarray(this.offset, this.offset + len), 'utf-8');\n        this.offset += len;\n        return value;\n    }\n    parseUserComment() {\n        const offset0 = this.offset;\n        const v = this.readStringUtf8();\n        const idx = v.indexOf('=');\n        return {\n            key: v.substring(0, idx).toUpperCase(),\n            value: v.substring(idx + 1),\n            len: this.offset - offset0\n        };\n    }\n}\n","import * as Token from 'token-types';\nimport debugInit from 'debug';\nimport { VorbisDecoder } from './VorbisDecoder.js';\nimport { CommonHeader, IdentificationHeader, VorbisPictureToken } from './Vorbis.js';\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\nconst debug = debugInit('music-metadata:parser:ogg:vorbis1');\nexport class VorbisContentError extends makeUnexpectedFileContentError('Vorbis') {\n}\n/**\n * Vorbis 1 Parser.\n * Used by OggStream\n */\nexport class VorbisStream {\n    constructor(metadata, options) {\n        this.pageSegments = [];\n        this.durationOnLastPage = true;\n        this.metadata = metadata;\n        this.options = options;\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        this.lastPageHeader = header;\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n        else {\n            if (header.headerType.continued) {\n                if (this.pageSegments.length === 0) {\n                    throw new VorbisContentError('Cannot continue on previous page');\n                }\n                this.pageSegments.push(pageData);\n            }\n            if (header.headerType.lastPage || !header.headerType.continued) {\n                // Flush page segments\n                if (this.pageSegments.length > 0) {\n                    const fullPage = VorbisStream.mergeUint8Arrays(this.pageSegments);\n                    await this.parseFullPage(fullPage);\n                }\n                // Reset page segments\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n            }\n        }\n    }\n    static mergeUint8Arrays(arrays) {\n        const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);\n        const merged = new Uint8Array(totalSize);\n        arrays.forEach((array, i, _arrays) => {\n            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);\n            merged.set(array, offset);\n        });\n        return merged;\n    }\n    async flush() {\n        await this.parseFullPage(VorbisStream.mergeUint8Arrays(this.pageSegments));\n    }\n    async parseUserComment(pageData, offset) {\n        const decoder = new VorbisDecoder(pageData, offset);\n        const tag = decoder.parseUserComment();\n        await this.addTag(tag.key, tag.value);\n        return tag.len;\n    }\n    async addTag(id, value) {\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\n            if (this.options.skipCovers) {\n                debug(\"Ignore picture\");\n                return;\n            }\n            value = VorbisPictureToken.fromBase64(value);\n            debug(`Push picture: id=${id}, format=${value.format}`);\n        }\n        else {\n            debug(`Push tag: id=${id}, value=${value}`);\n        }\n        await this.metadata.addTag('vorbis', id, value);\n    }\n    calculateDuration(enfOfStream) {\n        if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            this.metadata.setFormat('numberOfSamples', this.lastPageHeader.absoluteGranulePosition);\n            this.metadata.setFormat('duration', this.lastPageHeader.absoluteGranulePosition / this.metadata.format.sampleRate);\n        }\n    }\n    /**\n     * Parse first Ogg/Vorbis page\n     * @param _header\n     * @param pageData\n     */\n    parseFirstPage(_header, pageData) {\n        this.metadata.setFormat('codec', 'Vorbis I');\n        this.metadata.setFormat('hasAudio', true);\n        debug('Parse first page');\n        // Parse  Vorbis common header\n        const commonHeader = CommonHeader.get(pageData, 0);\n        if (commonHeader.vorbis !== 'vorbis')\n            throw new VorbisContentError('Metadata does not look like Vorbis');\n        if (commonHeader.packetType === 1) {\n            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n            debug('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n        }\n        else\n            throw new VorbisContentError('First Ogg page should be type 1: the identification header');\n    }\n    async parseFullPage(pageData) {\n        // New page\n        const commonHeader = CommonHeader.get(pageData, 0);\n        debug('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);\n        switch (commonHeader.packetType) {\n            case 3: //  type 3: comment header\n                return this.parseUserCommentList(pageData, CommonHeader.len);\n            case 1: // type 1: the identification header\n            case 5: // type 5: setup header type\n                break; // ignore\n        }\n    }\n    /**\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n     */\n    async parseUserCommentList(pageData, offset) {\n        const strLen = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n        offset += strLen;\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        while (userCommentListLength-- > 0) {\n            offset += (await this.parseUserComment(pageData, offset));\n        }\n    }\n}\n","import { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport { ID3v2Header } from './ID3v2Token.js';\nimport { ID3v2Parser } from './ID3v2Parser.js';\nimport { ID3v1Parser } from '../id3v1/ID3v1Parser.js';\nimport { BasicParser } from '../common/BasicParser.js';\nconst debug = initDebug('music-metadata:parser:ID3');\n/**\n * Abstract parser which tries take ID3v2 and ID3v1 headers.\n */\nexport class AbstractID3Parser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.id3parser = new ID3v2Parser();\n    }\n    static async startsWithID3v2Header(tokenizer) {\n        return (await tokenizer.peekToken(ID3v2Header)).fileIdentifier === 'ID3';\n    }\n    async parse() {\n        try {\n            await this.parseID3v2();\n        }\n        catch (err) {\n            if (err instanceof EndOfStreamError) {\n                debug(\"End-of-stream\");\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    finalize() {\n        return;\n    }\n    async parseID3v2() {\n        await this.tryReadId3v2Headers();\n        debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);\n        await this.postId3v2Parse();\n        if (this.options.skipPostHeaders && this.metadata.hasAny()) {\n            this.finalize();\n        }\n        else {\n            const id3v1parser = new ID3v1Parser(this.metadata, this.tokenizer, this.options);\n            await id3v1parser.parse();\n            this.finalize();\n        }\n    }\n    async tryReadId3v2Headers() {\n        const id3Header = await this.tokenizer.peekToken(ID3v2Header);\n        if (id3Header.fileIdentifier === 'ID3') {\n            debug('Found ID3v2 header, pos=%s', this.tokenizer.position);\n            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);\n            return this.tryReadId3v2Headers();\n        }\n    }\n}\n","import * as util from '../common/Util.js';\nimport { UINT16_BE, UINT24_BE, Uint8ArrayType } from 'token-types';\n/**\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\n * ref: https://xiph.org/flac/format.html#metadata_block\n */\nexport const BlockType = {\n    STREAMINFO: 0, // STREAMINFO\n    PADDING: 1, // PADDING\n    APPLICATION: 2, // APPLICATION\n    SEEKTABLE: 3, // SEEKTABLE\n    VORBIS_COMMENT: 4, // VORBIS_COMMENT\n    CUESHEET: 5, // CUESHEET\n    PICTURE: 6 // PICTURE\n};\nexport const BlockHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            lastBlock: util.getBit(buf, off, 7),\n            type: util.getBitAllignedNumber(buf, off, 1, 7),\n            length: UINT24_BE.get(buf, off + 1)\n        };\n    }\n};\n/**\n * METADATA_BLOCK_DATA\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\n */\nexport const BlockStreamInfo = {\n    len: 34,\n    get: (buf, off) => {\n        return {\n            // The minimum block size (in samples) used in the stream.\n            minimumBlockSize: UINT16_BE.get(buf, off),\n            // The maximum block size (in samples) used in the stream.\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n            maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1000,\n            // The minimum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            minimumFrameSize: UINT24_BE.get(buf, off + 4),\n            // The maximum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            maximumFrameSize: UINT24_BE.get(buf, off + 7),\n            // Sample rate in Hz. Though 20 bits are available,\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n            // Also, a value of 0 is invalid.\n            sampleRate: UINT24_BE.get(buf, off + 10) >> 4,\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\n            channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n            // bits per sample)-1.\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n            bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n            // Total samples in stream.\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n            // A value of zero here means the number of total samples is unknown.\n            totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n            fileMD5: new Uint8ArrayType(16).get(buf, off + 18)\n        };\n    }\n};\n","import * as Token from 'token-types';\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\nexport class OpusContentError extends makeUnexpectedFileContentError('Opus') {\n}\n/**\n * Opus ID Header parser\n * Ref: https://wiki.xiph.org/OggOpus#ID_Header\n */\nexport class IdHeader {\n    constructor(len) {\n        if (len < 19) {\n            throw new OpusContentError('ID-header-page 0 should be at least 19 bytes long');\n        }\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            magicSignature: new Token.StringType(8, 'ascii').get(buf, off + 0),\n            version: Token.UINT8.get(buf, off + 8),\n            channelCount: Token.UINT8.get(buf, off + 9),\n            preSkip: Token.UINT16_LE.get(buf, off + 10),\n            inputSampleRate: Token.UINT32_LE.get(buf, off + 12),\n            outputGain: Token.UINT16_LE.get(buf, off + 16),\n            channelMapping: Token.UINT8.get(buf, off + 18)\n        };\n    }\n}\n","import * as Token from 'token-types';\nimport { VorbisStream } from '../vorbis/VorbisStream.js';\nimport * as Opus from './Opus.js';\nimport { OpusContentError } from './Opus.js';\n/**\n * Opus parser\n * Internet Engineering Task Force (IETF) - RFC 6716\n * Used by OggStream\n */\nexport class OpusStream extends VorbisStream {\n    constructor(metadata, options, tokenizer) {\n        super(metadata, options);\n        this.idHeader = null;\n        this.lastPos = -1;\n        this.tokenizer = tokenizer;\n        this.durationOnLastPage = true;\n    }\n    /**\n     * Parse first Opus Ogg page\n     * @param {IPageHeader} header\n     * @param {Uint8Array} pageData\n     */\n    parseFirstPage(_header, pageData) {\n        this.metadata.setFormat('codec', 'Opus');\n        // Parse Opus ID Header\n        this.idHeader = new Opus.IdHeader(pageData.length).get(pageData, 0);\n        if (this.idHeader.magicSignature !== \"OpusHead\")\n            throw new OpusContentError(\"Illegal ogg/Opus magic-signature\");\n        this.metadata.setFormat('sampleRate', this.idHeader.inputSampleRate);\n        this.metadata.setFormat('numberOfChannels', this.idHeader.channelCount);\n        this.metadata.setAudioOnly();\n    }\n    async parseFullPage(pageData) {\n        const magicSignature = new Token.StringType(8, 'ascii').get(pageData, 0);\n        switch (magicSignature) {\n            case 'OpusTags':\n                await this.parseUserCommentList(pageData, 8);\n                this.lastPos = this.tokenizer.position - pageData.length;\n                break;\n            default:\n                break;\n        }\n    }\n    calculateDuration(enfOfStream) {\n        if (this.lastPageHeader && (enfOfStream || this.lastPageHeader.headerType.lastPage) && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            const pos_48bit = this.lastPageHeader.absoluteGranulePosition - this.idHeader.preSkip;\n            this.metadata.setFormat('numberOfSamples', pos_48bit);\n            this.metadata.setFormat('duration', pos_48bit / 48000);\n            if (this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n                const dataSize = this.tokenizer.fileInfo.size - this.lastPos;\n                this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n            }\n        }\n    }\n}\n","import * as Token from 'token-types';\nimport * as util from '../../common/Util.js';\n/**\n * Speex Header Packet\n * Ref: https://www.speex.org/docs/manual/speex-manual/node8.html#SECTION00830000000000000000\n */\nexport const Header = {\n    len: 80,\n    get: (buf, off) => {\n        return {\n            speex: new Token.StringType(8, 'ascii').get(buf, off + 0),\n            version: util.trimRightNull(new Token.StringType(20, 'ascii').get(buf, off + 8)),\n            version_id: Token.INT32_LE.get(buf, off + 28),\n            header_size: Token.INT32_LE.get(buf, off + 32),\n            rate: Token.INT32_LE.get(buf, off + 36),\n            mode: Token.INT32_LE.get(buf, off + 40),\n            mode_bitstream_version: Token.INT32_LE.get(buf, off + 44),\n            nb_channels: Token.INT32_LE.get(buf, off + 48),\n            bitrate: Token.INT32_LE.get(buf, off + 52),\n            frame_size: Token.INT32_LE.get(buf, off + 56),\n            vbr: Token.INT32_LE.get(buf, off + 60),\n            frames_per_packet: Token.INT32_LE.get(buf, off + 64),\n            extra_headers: Token.INT32_LE.get(buf, off + 68),\n            reserved1: Token.INT32_LE.get(buf, off + 72),\n            reserved2: Token.INT32_LE.get(buf, off + 76)\n        };\n    }\n};\n","import initDebug from 'debug';\nimport { VorbisStream } from '../vorbis/VorbisStream.js';\nimport * as Speex from './Speex.js';\nconst debug = initDebug('music-metadata:parser:ogg:speex');\n/**\n * Speex, RFC 5574\n * Ref:\n * - https://www.speex.org/docs/manual/speex-manual/\n * - https://tools.ietf.org/html/rfc5574\n */\nexport class SpeexStream extends VorbisStream {\n    constructor(metadata, options, _tokenizer) {\n        super(metadata, options);\n    }\n    /**\n     * Parse first Speex Ogg page\n     * @param {IPageHeader} header\n     * @param {Uint8Array} pageData\n     */\n    parseFirstPage(_header, pageData) {\n        debug('First Ogg/Speex page');\n        const speexHeader = Speex.Header.get(pageData, 0);\n        this.metadata.setFormat('codec', `Speex ${speexHeader.version}`);\n        this.metadata.setFormat('numberOfChannels', speexHeader.nb_channels);\n        this.metadata.setFormat('sampleRate', speexHeader.rate);\n        if (speexHeader.bitrate !== -1) {\n            this.metadata.setFormat('bitrate', speexHeader.bitrate);\n        }\n        this.metadata.setAudioOnly();\n    }\n}\n","import * as Token from 'token-types';\n/**\n * 6.2 Identification Header\n * Ref: https://theora.org/doc/Theora.pdf: 6.2 Identification Header Decode\n */\nexport const IdentificationHeader = {\n    len: 42,\n    get: (buf, off) => {\n        return {\n            id: new Token.StringType(7, 'ascii').get(buf, off),\n            vmaj: Token.UINT8.get(buf, off + 7),\n            vmin: Token.UINT8.get(buf, off + 8),\n            vrev: Token.UINT8.get(buf, off + 9),\n            vmbw: Token.UINT16_BE.get(buf, off + 10),\n            vmbh: Token.UINT16_BE.get(buf, off + 17),\n            nombr: Token.UINT24_BE.get(buf, off + 37),\n            nqual: Token.UINT8.get(buf, off + 40)\n        };\n    }\n};\n","import initDebug from 'debug';\nimport { IdentificationHeader } from './Theora.js';\nconst debug = initDebug('music-metadata:parser:ogg:theora');\n/**\n * Ref:\n * - https://theora.org/doc/Theora.pdf\n */\nexport class TheoraStream {\n    constructor(metadata, _options, _tokenizer) {\n        this.durationOnLastPage = false;\n        this.metadata = metadata;\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            await this.parseFirstPage(header, pageData);\n        }\n    }\n    calculateDuration() {\n        debug('duration calculation not implemented');\n    }\n    /**\n     * Parse first Theora Ogg page. the initial identification header packet\n     */\n    async parseFirstPage(_header, pageData) {\n        debug('First Ogg/Theora page');\n        this.metadata.setFormat('codec', 'Theora');\n        const idHeader = IdentificationHeader.get(pageData, 0);\n        this.metadata.setFormat('bitrate', idHeader.nombr);\n        this.metadata.setFormat('hasVideo', true);\n    }\n    flush() {\n        return Promise.resolve();\n    }\n}\n","import * as Token from 'token-types';\nimport * as util from '../common/Util.js';\nimport { StringType } from 'token-types';\nexport const PageHeader = {\n    len: 27,\n    get: (buf, off) => {\n        return {\n            capturePattern: new StringType(4, 'latin1').get(buf, off),\n            version: Token.UINT8.get(buf, off + 4),\n            headerType: {\n                continued: util.getBit(buf, off + 5, 0),\n                firstPage: util.getBit(buf, off + 5, 1),\n                lastPage: util.getBit(buf, off + 5, 2)\n            },\n            // packet_flag: Token.UINT8.get(buf, off + 5),\n            absoluteGranulePosition: Number(Token.UINT64_LE.get(buf, off + 6)),\n            streamSerialNumber: Token.UINT32_LE.get(buf, off + 14),\n            pageSequenceNo: Token.UINT32_LE.get(buf, off + 18),\n            pageChecksum: Token.UINT32_LE.get(buf, off + 22),\n            page_segments: Token.UINT8.get(buf, off + 26)\n        };\n    }\n};\nexport class SegmentTable {\n    static sum(buf, off, len) {\n        const dv = new DataView(buf.buffer, 0);\n        let s = 0;\n        for (let i = off; i < off + len; ++i) {\n            s += dv.getUint8(i);\n        }\n        return s;\n    }\n    constructor(header) {\n        this.len = header.page_segments;\n    }\n    get(buf, off) {\n        return {\n            totalPageSize: SegmentTable.sum(buf, off, this.len)\n        };\n    }\n}\n","import initDebug from 'debug';\nimport * as Flac from '../../flac/FlacToken.js';\nimport { FlacParser } from '../../flac/FlacParser.js';\nimport { FourCcToken } from '../../common/FourCC.js';\nimport { VorbisPictureToken } from '../vorbis/Vorbis.js';\nconst debug = initDebug('music-metadata:parser:ogg:theora');\n/**\n * Ref:\n * - https://xiph.org/flac/ogg_mapping.html\n */\nexport class FlacStream {\n    constructor(metadata, options, tokenizer) {\n        this.durationOnLastPage = false;\n        this.metadata = metadata;\n        this.options = options;\n        this.tokenizer = tokenizer;\n        this.flacParser = new FlacParser(this.metadata, this.tokenizer, options);\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            await this.parseFirstPage(header, pageData);\n        }\n    }\n    calculateDuration() {\n        debug('duration calculation not implemented');\n    }\n    /**\n     * Parse first Theora Ogg page. the initial identification header packet\n     */\n    async parseFirstPage(_header, pageData) {\n        debug('First Ogg/FLAC page');\n        const fourCC = await FourCcToken.get(pageData, 9);\n        if (fourCC.toString() !== 'fLaC') {\n            throw new Error('Invalid FLAC preamble');\n        }\n        const blockHeader = await Flac.BlockHeader.get(pageData, 13);\n        await this.parseDataBlock(blockHeader, pageData.subarray(13 + Flac.BlockHeader.len));\n    }\n    async parseDataBlock(blockHeader, pageData) {\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n        switch (blockHeader.type) {\n            case Flac.BlockType.STREAMINFO: {\n                const streamInfo = Flac.BlockStreamInfo.get(pageData, 0);\n                return this.flacParser.processsStreamInfo(streamInfo);\n            }\n            case Flac.BlockType.PADDING:\n                break;\n            case Flac.BlockType.APPLICATION:\n                break;\n            case Flac.BlockType.SEEKTABLE:\n                break;\n            case Flac.BlockType.VORBIS_COMMENT:\n                return this.flacParser.parseComment(pageData);\n            case Flac.BlockType.PICTURE:\n                if (!this.options.skipCovers) {\n                    const picture = new VorbisPictureToken(pageData.length).get(pageData, 0);\n                    return this.flacParser.addPictureTag(picture);\n                }\n                break;\n            default:\n                this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);\n        }\n        // Ignore data block\n        return this.tokenizer.ignore(blockHeader.length).then();\n    }\n    flush() {\n        return Promise.resolve();\n    }\n}\n","import * as Token from 'token-types';\nimport { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { VorbisStream } from './vorbis/VorbisStream.js';\nimport { OpusStream } from './opus/OpusStream.js';\nimport { SpeexStream } from './speex/SpeexStream.js';\nimport { TheoraStream } from './theora/TheoraStream.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport { PageHeader, SegmentTable } from './OggToken.js';\nimport { FlacStream } from './flac/FlacStream.js';\nexport class OggContentError extends makeUnexpectedFileContentError('Ogg') {\n}\nconst debug = initDebug('music-metadata:parser:ogg');\nclass OggStream {\n    constructor(metadata, streamSerial, options) {\n        this.pageNumber = 0;\n        this.closed = false;\n        this.metadata = metadata;\n        this.streamSerial = streamSerial;\n        this.options = options;\n    }\n    async parsePage(tokenizer, header) {\n        this.pageNumber = header.pageSequenceNo;\n        debug('serial=%s page#=%s, Ogg.id=%s', header.streamSerialNumber, header.pageSequenceNo, header.capturePattern);\n        const segmentTable = await tokenizer.readToken(new SegmentTable(header));\n        debug('totalPageSize=%s', segmentTable.totalPageSize);\n        const pageData = await tokenizer.readToken(new Token.Uint8ArrayType(segmentTable.totalPageSize));\n        debug('firstPage=%s, lastPage=%s, continued=%s', header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);\n        if (header.headerType.firstPage) {\n            this.metadata.setFormat('container', 'Ogg');\n            const idData = pageData.subarray(0, 7); // Copy this portion\n            const asciiId = Array.from(idData)\n                .filter(b => b >= 32 && b <= 126) // Keep only printable ASCII\n                .map(b => String.fromCharCode(b))\n                .join('');\n            switch (asciiId) {\n                case 'vorbis': // Ogg/Vorbis\n                    debug(`Set Ogg stream serial ${header.streamSerialNumber}, codec=Vorbis`);\n                    this.pageConsumer = new VorbisStream(this.metadata, this.options);\n                    break;\n                case 'OpusHea': // Ogg/Opus\n                    debug('Set page consumer to Ogg/Opus');\n                    this.pageConsumer = new OpusStream(this.metadata, this.options, tokenizer);\n                    break;\n                case 'Speex  ': // Ogg/Speex\n                    debug('Set page consumer to Ogg/Speex');\n                    this.pageConsumer = new SpeexStream(this.metadata, this.options, tokenizer);\n                    break;\n                case 'fishead':\n                case 'theora': // Ogg/Theora\n                    debug('Set page consumer to Ogg/Theora');\n                    this.pageConsumer = new TheoraStream(this.metadata, this.options, tokenizer);\n                    break;\n                case 'FLAC': // Ogg/Theora\n                    debug('Set page consumer to Vorbis');\n                    this.pageConsumer = new FlacStream(this.metadata, this.options, tokenizer);\n                    break;\n                default:\n                    throw new OggContentError(`Ogg codec not recognized (id=${asciiId}`);\n            }\n        }\n        if (header.headerType.lastPage) {\n            this.closed = true;\n        }\n        if (this.pageConsumer) {\n            await this.pageConsumer.parsePage(header, pageData);\n        }\n        else\n            throw new Error('pageConsumer should be initialized');\n    }\n}\n/**\n * Parser for Ogg logical bitstream framing\n */\nexport class OggParser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.streams = new Map();\n    }\n    /**\n     * Parse page\n     * @returns {Promise<void>}\n     */\n    async parse() {\n        this.streams = new Map();\n        let enfOfStream = false;\n        let header;\n        try {\n            do {\n                header = await this.tokenizer.readToken(PageHeader);\n                if (header.capturePattern !== 'OggS')\n                    throw new OggContentError('Invalid Ogg capture pattern');\n                let stream = this.streams.get(header.streamSerialNumber);\n                if (!stream) {\n                    stream = new OggStream(this.metadata, header.streamSerialNumber, this.options);\n                    this.streams.set(header.streamSerialNumber, stream);\n                }\n                await stream.parsePage(this.tokenizer, header);\n                if (stream.pageNumber > 12 && !(this.options.duration && [...this.streams.values()].find(stream => stream.pageConsumer?.durationOnLastPage))) {\n                    debug(\"Stop processing Ogg stream\");\n                    break;\n                }\n            } while (![...this.streams.values()].every(item => item.closed));\n        }\n        catch (err) {\n            if (err instanceof EndOfStreamError) {\n                debug(\"Reached end-of-stream\");\n                enfOfStream = true;\n            }\n            else if (err instanceof OggContentError) {\n                this.metadata.addWarning(`Corrupt Ogg content at ${this.tokenizer.position}`);\n            }\n            else\n                throw err;\n        }\n        for (const stream of this.streams.values()) {\n            if (!stream.closed) {\n                this.metadata.addWarning(`End-of-stream reached before reaching last page in Ogg stream serial=${stream.streamSerial}`);\n                await stream.pageConsumer?.flush();\n            }\n            stream.pageConsumer?.calculateDuration(enfOfStream);\n        }\n    }\n}\n","import * as Token from 'token-types';\nimport { AttachedPictureType } from '../../id3v2/ID3v2Token.js';\n/**\n * Parse the METADATA_BLOCK_PICTURE\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\n * // ToDo: move to ID3 / APIC?\n */\nexport class VorbisPictureToken {\n    static fromBase64(base64str) {\n        return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), c => c.charCodeAt(0)));\n    }\n    static fromBuffer(buffer) {\n        const pic = new VorbisPictureToken(buffer.length);\n        return pic.get(buffer, 0);\n    }\n    constructor(len) {\n        this.len = len;\n    }\n    get(buffer, offset) {\n        const type = AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];\n        offset += 4;\n        const mimeLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const format = new Token.StringType(mimeLen, 'utf-8').get(buffer, offset);\n        offset += mimeLen;\n        const descLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const description = new Token.StringType(descLen, 'utf-8').get(buffer, offset);\n        offset += descLen;\n        const width = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const height = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const colour_depth = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const indexed_color = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const picDataLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const data = buffer.slice(offset, offset + picDataLen);\n        return {\n            type,\n            format,\n            description,\n            width,\n            height,\n            colour_depth,\n            indexed_color,\n            data\n        };\n    }\n}\n/**\n * Comment header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\n */\nexport const CommonHeader = {\n    len: 7,\n    get: (buf, off) => {\n        return {\n            packetType: Token.UINT8.get(buf, off),\n            vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)\n        };\n    }\n};\n/**\n * Identification header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\n */\nexport const IdentificationHeader = {\n    len: 23,\n    get: (uint8Array, off) => {\n        return {\n            version: Token.UINT32_LE.get(uint8Array, off + 0),\n            channelMode: Token.UINT8.get(uint8Array, off + 4),\n            sampleRate: Token.UINT32_LE.get(uint8Array, off + 5),\n            bitrateMax: Token.UINT32_LE.get(uint8Array, off + 9),\n            bitrateNominal: Token.UINT32_LE.get(uint8Array, off + 13),\n            bitrateMin: Token.UINT32_LE.get(uint8Array, off + 17)\n        };\n    }\n};\n"],"names":["debug","initDebug","FlacContentError","makeUnexpectedFileContentError","FlacParser","AbstractID3Parser","constructor","super","arguments","this","vorbisParser","VorbisStream","metadata","options","padding","postId3v2Parse","tokenizer","readToken","FourCcToken","toString","blockHeader","Flac","parseDataBlock","lastBlock","fileInfo","size","format","duration","dataSize","position","setFormat","concat","type","length","STREAMINFO","readBlockStreamInfo","PADDING","APPLICATION","SEEKTABLE","VORBIS_COMMENT","readComment","CUESHEET","PICTURE","parsePicture","addWarning","ignore","then","dataLen","len","streamInfo","processsStreamInfo","channels","bitsPerSample","sampleRate","totalSamples","data","Uint8ArrayType","parseComment","decoder","VorbisDecoder","vendor","readStringUtf8","commentListLength","readInt32","tags","Array","i","parseUserComment","Promise","all","map","tag","key","value","addTag","skipCovers","addPictureTag","VorbisPictureToken","picture","id","offset","Token","get","textDecode","subarray","offset0","v","idx","indexOf","substring","toUpperCase","debugInit","VorbisContentError","pageSegments","durationOnLastPage","parsePage","header","pageData","lastPageHeader","headerType","firstPage","parseFirstPage","continued","push","lastPage","fullPage","mergeUint8Arrays","parseFullPage","arrays","totalSize","reduce","acc","e","merged","Uint8Array","forEach","array","_arrays","slice","set","flush","fromBase64","calculateDuration","enfOfStream","absoluteGranulePosition","_header","commonHeader","CommonHeader","vorbis","packetType","idHeader","IdentificationHeader","bitrateNominal","channelMode","byteLength","parseUserCommentList","strLen","userCommentListLength","BasicParser","id3parser","ID3v2Parser","startsWithID3v2Header","peekToken","ID3v2Header","fileIdentifier","parse","parseID3v2","err","EndOfStreamError","finalize","tryReadId3v2Headers","skipPostHeaders","hasAny","id3v1parser","ID3v1Parser","BlockType","BlockHeader","buf","off","util","UINT24_BE","BlockStreamInfo","minimumBlockSize","UINT16_BE","maximumBlockSize","minimumFrameSize","maximumFrameSize","fileMD5","OpusContentError","IdHeader","magicSignature","version","channelCount","preSkip","inputSampleRate","outputGain","channelMapping","OpusStream","lastPos","Opus","setAudioOnly","pos_48bit","Header","speex","version_id","header_size","rate","mode","mode_bitstream_version","nb_channels","bitrate","frame_size","vbr","frames_per_packet","extra_headers","reserved1","reserved2","SpeexStream","_tokenizer","speexHeader","Speex","vmaj","vmin","vrev","vmbw","vmbh","nombr","nqual","TheoraStream","_options","resolve","PageHeader","capturePattern","StringType","Number","streamSerialNumber","pageSequenceNo","pageChecksum","page_segments","SegmentTable","sum","dv","DataView","buffer","s","getUint8","totalPageSize","FlacStream","flacParser","Error","OggContentError","OggStream","streamSerial","pageNumber","closed","segmentTable","idData","asciiId","from","filter","b","String","fromCharCode","join","pageConsumer","OggParser","streams","Map","stream","values","find","_stream$pageConsumer","every","item","_stream$pageConsumer3","_stream$pageConsumer2","base64str","fromBuffer","atob","c","charCodeAt","AttachedPictureType","mimeLen","descLen","description","width","height","colour_depth","indexed_color","picDataLen","uint8Array","bitrateMax","bitrateMin"],"sourceRoot":""}