{"version":3,"file":"static/js/812.18c202fb.chunk.js","mappings":"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","sources":["../node_modules/music-metadata/lib/ogg/opus/Opus.js","../node_modules/music-metadata/lib/ogg/opus/OpusParser.js","../node_modules/music-metadata/lib/ogg/speex/Speex.js","../node_modules/music-metadata/lib/ogg/speex/SpeexParser.js","../node_modules/music-metadata/lib/ogg/theora/Theora.js","../node_modules/music-metadata/lib/ogg/theora/TheoraParser.js","../node_modules/music-metadata/lib/ogg/OggParser.js","../node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js","../node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js","../node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js"],"sourcesContent":["import * as Token from 'token-types';\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\nexport class OpusContentError extends makeUnexpectedFileContentError('Opus') {\n}\n/**\n * Opus ID Header parser\n * Ref: https://wiki.xiph.org/OggOpus#ID_Header\n */\nexport class IdHeader {\n    constructor(len) {\n        if (len < 19) {\n            throw new OpusContentError('ID-header-page 0 should be at least 19 bytes long');\n        }\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            magicSignature: new Token.StringType(8, 'ascii').get(buf, off + 0),\n            version: Token.UINT8.get(buf, off + 8),\n            channelCount: Token.UINT8.get(buf, off + 9),\n            preSkip: Token.UINT16_LE.get(buf, off + 10),\n            inputSampleRate: Token.UINT32_LE.get(buf, off + 12),\n            outputGain: Token.UINT16_LE.get(buf, off + 16),\n            channelMapping: Token.UINT8.get(buf, off + 18)\n        };\n    }\n}\n//# sourceMappingURL=Opus.js.map","import * as Token from 'token-types';\nimport { VorbisParser } from '../vorbis/VorbisParser.js';\nimport * as Opus from './Opus.js';\nimport { OpusContentError } from './Opus.js';\n/**\n * Opus parser\n * Internet Engineering Task Force (IETF) - RFC 6716\n * Used by OggParser\n */\nexport class OpusParser extends VorbisParser {\n    constructor(metadata, options, tokenizer) {\n        super(metadata, options);\n        this.idHeader = null;\n        this.lastPos = -1;\n        this.tokenizer = tokenizer;\n    }\n    /**\n     * Parse first Opus Ogg page\n     * @param {IPageHeader} header\n     * @param {Uint8Array} pageData\n     */\n    parseFirstPage(header, pageData) {\n        this.metadata.setFormat('codec', 'Opus');\n        // Parse Opus ID Header\n        this.idHeader = new Opus.IdHeader(pageData.length).get(pageData, 0);\n        if (this.idHeader.magicSignature !== \"OpusHead\")\n            throw new OpusContentError(\"Illegal ogg/Opus magic-signature\");\n        this.metadata.setFormat('sampleRate', this.idHeader.inputSampleRate);\n        this.metadata.setFormat('numberOfChannels', this.idHeader.channelCount);\n    }\n    async parseFullPage(pageData) {\n        const magicSignature = new Token.StringType(8, 'ascii').get(pageData, 0);\n        switch (magicSignature) {\n            case 'OpusTags':\n                await this.parseUserCommentList(pageData, 8);\n                this.lastPos = this.tokenizer.position - pageData.length;\n                break;\n            default:\n                break;\n        }\n    }\n    calculateDuration(header) {\n        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            const pos_48bit = header.absoluteGranulePosition - this.idHeader.preSkip;\n            this.metadata.setFormat('numberOfSamples', pos_48bit);\n            this.metadata.setFormat('duration', pos_48bit / 48000);\n            if (this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n                const dataSize = this.tokenizer.fileInfo.size - this.lastPos;\n                this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n            }\n        }\n    }\n}\n//# sourceMappingURL=OpusParser.js.map","import * as Token from 'token-types';\nimport * as util from '../../common/Util.js';\n/**\n * Speex Header Packet\n * Ref: https://www.speex.org/docs/manual/speex-manual/node8.html#SECTION00830000000000000000\n */\nexport const Header = {\n    len: 80,\n    get: (buf, off) => {\n        return {\n            speex: new Token.StringType(8, 'ascii').get(buf, off + 0),\n            version: util.trimRightNull(new Token.StringType(20, 'ascii').get(buf, off + 8)),\n            version_id: Token.INT32_LE.get(buf, off + 28),\n            header_size: Token.INT32_LE.get(buf, off + 32),\n            rate: Token.INT32_LE.get(buf, off + 36),\n            mode: Token.INT32_LE.get(buf, off + 40),\n            mode_bitstream_version: Token.INT32_LE.get(buf, off + 44),\n            nb_channels: Token.INT32_LE.get(buf, off + 48),\n            bitrate: Token.INT32_LE.get(buf, off + 52),\n            frame_size: Token.INT32_LE.get(buf, off + 56),\n            vbr: Token.INT32_LE.get(buf, off + 60),\n            frames_per_packet: Token.INT32_LE.get(buf, off + 64),\n            extra_headers: Token.INT32_LE.get(buf, off + 68),\n            reserved1: Token.INT32_LE.get(buf, off + 72),\n            reserved2: Token.INT32_LE.get(buf, off + 76)\n        };\n    }\n};\n//# sourceMappingURL=Speex.js.map","import initDebug from 'debug';\nimport { VorbisParser } from '../vorbis/VorbisParser.js';\nimport * as Speex from './Speex.js';\nconst debug = initDebug('music-metadata:parser:ogg:speex');\n/**\n * Speex, RFC 5574\n * Ref:\n * - https://www.speex.org/docs/manual/speex-manual/\n * - https://tools.ietf.org/html/rfc5574\n */\nexport class SpeexParser extends VorbisParser {\n    constructor(metadata, options, tokenizer) {\n        super(metadata, options);\n        this.tokenizer = tokenizer;\n    }\n    /**\n     * Parse first Speex Ogg page\n     * @param {IPageHeader} header\n     * @param {Uint8Array} pageData\n     */\n    parseFirstPage(header, pageData) {\n        debug('First Ogg/Speex page');\n        const speexHeader = Speex.Header.get(pageData, 0);\n        this.metadata.setFormat('codec', `Speex ${speexHeader.version}`);\n        this.metadata.setFormat('numberOfChannels', speexHeader.nb_channels);\n        this.metadata.setFormat('sampleRate', speexHeader.rate);\n        if (speexHeader.bitrate !== -1) {\n            this.metadata.setFormat('bitrate', speexHeader.bitrate);\n        }\n    }\n}\n//# sourceMappingURL=SpeexParser.js.map","import * as Token from 'token-types';\n/**\n * 6.2 Identification Header\n * Ref: https://theora.org/doc/Theora.pdf: 6.2 Identification Header Decode\n */\nexport const IdentificationHeader = {\n    len: 42,\n    get: (buf, off) => {\n        return {\n            id: new Token.StringType(7, 'ascii').get(buf, off),\n            vmaj: Token.UINT8.get(buf, off + 7),\n            vmin: Token.UINT8.get(buf, off + 8),\n            vrev: Token.UINT8.get(buf, off + 9),\n            vmbw: Token.UINT16_BE.get(buf, off + 10),\n            vmbh: Token.UINT16_BE.get(buf, off + 17),\n            nombr: Token.UINT24_BE.get(buf, off + 37),\n            nqual: Token.UINT8.get(buf, off + 40)\n        };\n    }\n};\n//# sourceMappingURL=Theora.js.map","import initDebug from 'debug';\nimport { IdentificationHeader } from './Theora.js';\nconst debug = initDebug('music-metadata:parser:ogg:theora');\n/**\n * Ref:\n * - https://theora.org/doc/Theora.pdf\n */\nexport class TheoraParser {\n    constructor(metadata, options, tokenizer) {\n        this.metadata = metadata;\n        this.tokenizer = tokenizer;\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            await this.parseFirstPage(header, pageData);\n        }\n    }\n    async flush() {\n        debug('flush');\n    }\n    calculateDuration(header) {\n        debug('duration calculation not implemented');\n    }\n    /**\n     * Parse first Theora Ogg page. the initial identification header packet\n     * @param {IPageHeader} header\n     * @param {Buffer} pageData\n     */\n    async parseFirstPage(header, pageData) {\n        debug('First Ogg/Theora page');\n        this.metadata.setFormat('codec', 'Theora');\n        const idHeader = IdentificationHeader.get(pageData, 0);\n        this.metadata.setFormat('bitrate', idHeader.nombr);\n    }\n}\n//# sourceMappingURL=TheoraParser.js.map","import * as Token from 'token-types';\nimport { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport * as util from '../common/Util.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { VorbisParser } from './vorbis/VorbisParser.js';\nimport { OpusParser } from './opus/OpusParser.js';\nimport { SpeexParser } from './speex/SpeexParser.js';\nimport { TheoraParser } from './theora/TheoraParser.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nexport class OggContentError extends makeUnexpectedFileContentError('Ogg') {\n}\nconst debug = initDebug('music-metadata:parser:ogg');\nexport class SegmentTable {\n    static sum(buf, off, len) {\n        const dv = new DataView(buf.buffer, 0);\n        let s = 0;\n        for (let i = off; i < off + len; ++i) {\n            s += dv.getUint8(i);\n        }\n        return s;\n    }\n    constructor(header) {\n        this.len = header.page_segments;\n    }\n    get(buf, off) {\n        return {\n            totalPageSize: SegmentTable.sum(buf, off, this.len)\n        };\n    }\n}\n/**\n * Parser for Ogg logical bitstream framing\n */\nexport class OggParser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.header = null;\n        this.pageNumber = 0;\n        this.pageConsumer = null;\n    }\n    /**\n     * Parse page\n     * @returns {Promise<void>}\n     */\n    async parse() {\n        debug('pos=%s, parsePage()', this.tokenizer.position);\n        try {\n            let header;\n            do {\n                header = await this.tokenizer.readToken(OggParser.Header);\n                if (header.capturePattern !== 'OggS')\n                    throw new OggContentError('Invalid Ogg capture pattern');\n                this.metadata.setFormat('container', 'Ogg');\n                this.header = header;\n                this.pageNumber = header.pageSequenceNo;\n                debug('page#=%s, Ogg.id=%s', header.pageSequenceNo, header.capturePattern);\n                const segmentTable = await this.tokenizer.readToken(new SegmentTable(header));\n                debug('totalPageSize=%s', segmentTable.totalPageSize);\n                const pageData = await this.tokenizer.readToken(new Token.Uint8ArrayType(segmentTable.totalPageSize));\n                debug('firstPage=%s, lastPage=%s, continued=%s', header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);\n                if (header.headerType.firstPage) {\n                    const id = new TextDecoder('ascii').decode(pageData.subarray(0, 7));\n                    switch (id) {\n                        case '\\x01vorbis': // Ogg/Vorbis\n                            debug('Set page consumer to Ogg/Vorbis');\n                            this.pageConsumer = new VorbisParser(this.metadata, this.options);\n                            break;\n                        case 'OpusHea': // Ogg/Opus\n                            debug('Set page consumer to Ogg/Opus');\n                            this.pageConsumer = new OpusParser(this.metadata, this.options, this.tokenizer);\n                            break;\n                        case 'Speex  ': // Ogg/Speex\n                            debug('Set page consumer to Ogg/Speex');\n                            this.pageConsumer = new SpeexParser(this.metadata, this.options, this.tokenizer);\n                            break;\n                        case 'fishead':\n                        case '\\x00theora': // Ogg/Theora\n                            debug('Set page consumer to Ogg/Theora');\n                            this.pageConsumer = new TheoraParser(this.metadata, this.options, this.tokenizer);\n                            break;\n                        default:\n                            throw new OggContentError(`gg audio-codec not recognized (id=${id})`);\n                    }\n                }\n                await this.pageConsumer.parsePage(header, pageData);\n            } while (!header.headerType.lastPage);\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                if (err instanceof EndOfStreamError) {\n                    this.metadata.addWarning('Last OGG-page is not marked with last-page flag');\n                    debug(\"End-of-stream\");\n                    this.metadata.addWarning('Last OGG-page is not marked with last-page flag');\n                    if (this.header) {\n                        this.pageConsumer.calculateDuration(this.header);\n                    }\n                }\n                else if (err.message.startsWith('FourCC')) {\n                    if (this.pageNumber > 0) {\n                        // ignore this error: work-around if last OGG-page is not marked with last-page flag\n                        this.metadata.addWarning('Invalid FourCC ID, maybe last OGG-page is not marked with last-page flag');\n                        await this.pageConsumer.flush();\n                    }\n                }\n            }\n            else\n                throw err;\n        }\n    }\n}\nOggParser.Header = {\n    len: 27,\n    get: (buf, off) => {\n        return {\n            capturePattern: FourCcToken.get(buf, off),\n            version: Token.UINT8.get(buf, off + 4),\n            headerType: {\n                continued: util.getBit(buf, off + 5, 0),\n                firstPage: util.getBit(buf, off + 5, 1),\n                lastPage: util.getBit(buf, off + 5, 2)\n            },\n            // packet_flag: Token.UINT8.get(buf, off + 5),\n            absoluteGranulePosition: Number(Token.UINT64_LE.get(buf, off + 6)),\n            streamSerialNumber: Token.UINT32_LE.get(buf, off + 14),\n            pageSequenceNo: Token.UINT32_LE.get(buf, off + 18),\n            pageChecksum: Token.UINT32_LE.get(buf, off + 22),\n            page_segments: Token.UINT8.get(buf, off + 26)\n        };\n    }\n};\n//# sourceMappingURL=OggParser.js.map","import * as Token from 'token-types';\nexport class VorbisDecoder {\n    constructor(data, offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n    readInt32() {\n        const value = Token.UINT32_LE.get(this.data, this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readStringUtf8() {\n        const len = this.readInt32();\n        const value = new TextDecoder('utf-8').decode(this.data.subarray(this.offset, this.offset + len));\n        this.offset += len;\n        return value;\n    }\n    parseUserComment() {\n        const offset0 = this.offset;\n        const v = this.readStringUtf8();\n        const idx = v.indexOf('=');\n        return {\n            key: v.slice(0, idx).toUpperCase(),\n            value: v.slice(idx + 1),\n            len: this.offset - offset0\n        };\n    }\n}\n//# sourceMappingURL=VorbisDecoder.js.map","import * as Token from 'token-types';\nimport debugInit from 'debug';\nimport { VorbisDecoder } from './VorbisDecoder.js';\nimport { CommonHeader, IdentificationHeader, VorbisPictureToken } from './Vorbis.js';\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\nconst debug = debugInit('music-metadata:parser:ogg:vorbis1');\nexport class VorbisContentError extends makeUnexpectedFileContentError('Vorbis') {\n}\n/**\n * Vorbis 1 Parser.\n * Used by OggParser\n */\nexport class VorbisParser {\n    constructor(metadata, options) {\n        this.pageSegments = [];\n        this.metadata = metadata;\n        this.options = options;\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n        else {\n            if (header.headerType.continued) {\n                if (this.pageSegments.length === 0) {\n                    throw new VorbisContentError('Cannot continue on previous page');\n                }\n                this.pageSegments.push(pageData);\n            }\n            if (header.headerType.lastPage || !header.headerType.continued) {\n                // Flush page segments\n                if (this.pageSegments.length > 0) {\n                    const fullPage = VorbisParser.mergeUint8Arrays(this.pageSegments);\n                    await this.parseFullPage(fullPage);\n                }\n                // Reset page segments\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n            }\n        }\n        if (header.headerType.lastPage) {\n            this.calculateDuration(header);\n        }\n    }\n    static mergeUint8Arrays(arrays) {\n        const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);\n        const merged = new Uint8Array(totalSize);\n        arrays.forEach((array, i, _arrays) => {\n            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);\n            merged.set(array, offset);\n        });\n        return merged;\n    }\n    async flush() {\n        await this.parseFullPage(VorbisParser.mergeUint8Arrays(this.pageSegments));\n    }\n    async parseUserComment(pageData, offset) {\n        const decoder = new VorbisDecoder(pageData, offset);\n        const tag = decoder.parseUserComment();\n        await this.addTag(tag.key, tag.value);\n        return tag.len;\n    }\n    async addTag(id, value) {\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\n            if (this.options.skipCovers) {\n                debug(\"Ignore picture\");\n                return;\n            }\n            value = VorbisPictureToken.fromBase64(value);\n            debug(`Push picture: id=${id}, format=${value.format}`);\n        }\n        else {\n            debug(`Push tag: id=${id}, value=${value}`);\n        }\n        await this.metadata.addTag('vorbis', id, value);\n    }\n    calculateDuration(header) {\n        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            this.metadata.setFormat('numberOfSamples', header.absoluteGranulePosition);\n            this.metadata.setFormat('duration', header.absoluteGranulePosition / this.metadata.format.sampleRate);\n        }\n    }\n    /**\n     * Parse first Ogg/Vorbis page\n     * @param header\n     * @param pageData\n     */\n    parseFirstPage(header, pageData) {\n        this.metadata.setFormat('codec', 'Vorbis I');\n        debug('Parse first page');\n        // Parse  Vorbis common header\n        const commonHeader = CommonHeader.get(pageData, 0);\n        if (commonHeader.vorbis !== 'vorbis')\n            throw new VorbisContentError('Metadata does not look like Vorbis');\n        if (commonHeader.packetType === 1) {\n            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n            debug('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n        }\n        else\n            throw new VorbisContentError('First Ogg page should be type 1: the identification header');\n    }\n    async parseFullPage(pageData) {\n        // New page\n        const commonHeader = CommonHeader.get(pageData, 0);\n        debug('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);\n        switch (commonHeader.packetType) {\n            case 3: //  type 3: comment header\n                return this.parseUserCommentList(pageData, CommonHeader.len);\n            case 1: // type 1: the identification header\n            case 5: // type 5: setup header type\n                break; // ignore\n        }\n    }\n    /**\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n     */\n    async parseUserCommentList(pageData, offset) {\n        const strLen = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n        offset += strLen;\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        while (userCommentListLength-- > 0) {\n            offset += (await this.parseUserComment(pageData, offset));\n        }\n    }\n}\n//# sourceMappingURL=VorbisParser.js.map","import * as Token from 'token-types';\nimport { AttachedPictureType } from '../../id3v2/ID3v2Token.js';\n/**\n * Parse the METADATA_BLOCK_PICTURE\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\n * // ToDo: move to ID3 / APIC?\n */\nexport class VorbisPictureToken {\n    static fromBase64(base64str) {\n        return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), c => c.charCodeAt(0)));\n    }\n    static fromBuffer(buffer) {\n        const pic = new VorbisPictureToken(buffer.length);\n        return pic.get(buffer, 0);\n    }\n    constructor(len) {\n        this.len = len;\n    }\n    get(buffer, offset) {\n        const type = AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];\n        offset += 4;\n        const mimeLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const format = new Token.StringType(mimeLen, 'utf-8').get(buffer, offset);\n        offset += mimeLen;\n        const descLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const description = new Token.StringType(descLen, 'utf-8').get(buffer, offset);\n        offset += descLen;\n        const width = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const height = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const colour_depth = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const indexed_color = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const picDataLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const data = Uint8Array.from(buffer.slice(offset, offset + picDataLen));\n        return {\n            type,\n            format,\n            description,\n            width,\n            height,\n            colour_depth,\n            indexed_color,\n            data\n        };\n    }\n}\n/**\n * Comment header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\n */\nexport const CommonHeader = {\n    len: 7,\n    get: (buf, off) => {\n        return {\n            packetType: Token.UINT8.get(buf, off),\n            vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)\n        };\n    }\n};\n/**\n * Identification header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\n */\nexport const IdentificationHeader = {\n    len: 23,\n    get: (uint8Array, off) => {\n        return {\n            version: Token.UINT32_LE.get(uint8Array, off + 0),\n            channelMode: Token.UINT8.get(uint8Array, off + 4),\n            sampleRate: Token.UINT32_LE.get(uint8Array, off + 5),\n            bitrateMax: Token.UINT32_LE.get(uint8Array, off + 9),\n            bitrateNominal: Token.UINT32_LE.get(uint8Array, off + 13),\n            bitrateMin: Token.UINT32_LE.get(uint8Array, off + 17)\n        };\n    }\n};\n//# sourceMappingURL=Vorbis.js.map"],"names":["OpusContentError","makeUnexpectedFileContentError","IdHeader","constructor","len","this","get","buf","off","magicSignature","Token","version","channelCount","preSkip","inputSampleRate","outputGain","channelMapping","OpusParser","VorbisParser","metadata","options","tokenizer","super","idHeader","lastPos","parseFirstPage","header","pageData","setFormat","Opus","length","parseFullPage","parseUserCommentList","position","calculateDuration","format","sampleRate","absoluteGranulePosition","pos_48bit","fileInfo","size","duration","dataSize","Header","speex","util","version_id","header_size","rate","mode","mode_bitstream_version","nb_channels","bitrate","frame_size","vbr","frames_per_packet","extra_headers","reserved1","reserved2","debug","initDebug","SpeexParser","speexHeader","Speex","concat","IdentificationHeader","id","vmaj","vmin","vrev","vmbw","vmbh","nombr","nqual","TheoraParser","parsePage","headerType","firstPage","flush","OggContentError","SegmentTable","sum","dv","DataView","buffer","s","i","getUint8","page_segments","totalPageSize","OggParser","BasicParser","arguments","pageNumber","pageConsumer","parse","readToken","capturePattern","pageSequenceNo","segmentTable","lastPage","continued","TextDecoder","decode","subarray","err","Error","EndOfStreamError","addWarning","message","startsWith","FourCcToken","Number","streamSerialNumber","pageChecksum","VorbisDecoder","data","offset","readInt32","value","readStringUtf8","parseUserComment","offset0","v","idx","indexOf","key","slice","toUpperCase","debugInit","VorbisContentError","pageSegments","push","fullPage","mergeUint8Arrays","arrays","totalSize","reduce","acc","e","merged","Uint8Array","forEach","array","_arrays","set","tag","addTag","skipCovers","VorbisPictureToken","fromBase64","commonHeader","CommonHeader","vorbis","packetType","bitrateNominal","channelMode","byteLength","strLen","userCommentListLength","base64str","fromBuffer","from","atob","c","charCodeAt","type","AttachedPictureType","mimeLen","descLen","description","width","height","colour_depth","indexed_color","picDataLen","uint8Array","bitrateMax","bitrateMin"],"sourceRoot":""}