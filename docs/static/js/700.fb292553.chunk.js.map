{"version":3,"file":"static/js/700.fb292553.chunk.js","mappings":"8LAIO,MAAMA,EACJ,GADIA,EAEJC,CAACC,EAAKC,KACP,MAAMC,EAAcC,EAAAA,UAAgBJ,IAAIC,EAAKC,EAAM,GAC7CG,EAAYD,EAAAA,UAAgBJ,IAAIC,EAAKC,EAAM,IACjD,MAAO,CACHI,UAAWF,EAAAA,UAAgBJ,IAAIC,EAAKC,GACpCK,QAASH,EAAAA,UAAgBJ,IAAIC,EAAKC,EAAM,GACxCC,YAA6B,aAAhBA,OAA6BK,EAAYL,EACtDE,UAAyB,aAAdA,OAA2BG,EAAYH,I,cCJvD,SAASI,EAAqBC,GACjC,OAAQA,GACJ,KAAK,EAAG,OAAO,EACf,KAAK,EACL,KAAK,EAAG,OAAO,GACf,QAAS,MAAMC,EAAgCD,GAEvD,CACA,SAASE,EAAeC,GACpB,MAAO,CACHC,OAAQ,CACJC,uBAAwBC,EAAAA,GAAYH,EAAG,EAAG,GAC1CI,wBAAyBD,EAAAA,GAAYH,EAAG,EAAG,GAC3CK,UAAWF,EAAAA,GAAYH,EAAG,EAAG,IAEjCM,OAAQ,CACJC,kBAAmBJ,EAAAA,GAAYH,EAAG,EAAG,GACrCQ,YAAaL,EAAAA,GAAYH,EAAG,EAAG,GAC/BS,WAAYN,EAAAA,GAAYH,EAAG,EAAG,GAC9BU,kBAAmBP,EAAAA,GAAYH,EAAG,EAAG,GACrCW,sBAAuBR,EAAAA,GAAYH,EAAG,EAAG,IAGrD,CAMO,SAASY,EAAgBC,EAAYhB,EAAUiB,GAClD,OAAQjB,GACJ,KAAK,EACD,OAQZ,SAA6BgB,EAAYhB,EAAUiB,GAC/C,MAAMC,EAAS,CACXC,IAAIC,EAAAA,EAAAA,GAAWJ,EAAWK,SAAS,EAAG,GAAI,SAC1CC,OAAQ5B,EAAAA,UAAgBJ,IAAI0B,EAAY,IAEvCE,EAAOC,GAAGI,MAAM,kBACjBN,EAAiBO,WAAW,iBAADC,OAAkBzB,EAAQ,sBAAAyB,OAAqBP,EAAOC,KAErF,OAAOD,CACX,CAjBmBQ,CAAoBV,EAAYhB,EAAUiB,GACrD,KAAK,EACL,KAAK,EACD,OAeZ,SAAgCD,EAAYhB,EAAUiB,GAClD,MAAMC,EAAS,CACXC,IAAIC,EAAAA,EAAAA,GAAWJ,EAAWK,SAAS,EAAG,GAAI,SAC1CC,QAAsB,IAAbtB,EAAiB2B,EAAAA,GAAiBjC,EAAAA,WAAiBJ,IAAI0B,EAAY,GAC5EY,MAAO1B,EAAec,EAAWK,SAAS,EAAG,MAE5CH,EAAOC,GAAGI,MAAM,kBACjBN,EAAiBO,WAAW,iBAADC,OAAkBzB,EAAQ,sBAAAyB,OAAqBP,EAAOC,KAErF,OAAOD,CACX,CAzBmBW,CAAuBb,EAAYhB,EAAUiB,GACxD,QACI,MAAMhB,EAAgCD,GAElD,CAsBA,SAASC,EAAgCD,GACrC,MAAM,IAAI8B,EAAkB,wBAADL,OAAyBzB,GACxD,CC/DA,MAAM+B,EAAQC,EAAU,qCAClBC,EAAa,SACbC,EAAS,CAAEC,SAAUF,EAAYG,KAAK,GA2C5C,SAASC,EAAeC,GACpB,MAAa,OAATA,EACO,QACE,OAATA,EACO,QACPA,EAAKf,MAAM,SACJgB,EAAAA,GAAOC,OAAOC,SAASH,EAAM,UADxC,CAGJ,CACO,MAAMI,EAMTC,WAAAA,CAAYC,EAAO3B,GACf4B,KAAKD,MAAQA,EACbC,KAAK5B,iBAAmBA,CAC5B,CACA6B,QAAAA,CAAS9B,EAAY+B,EAAMC,GACvB,GAA0B,IAAtBhC,EAAWM,OAEX,YADAuB,KAAK5B,iBAAiBO,WAAW,SAADC,OAAUoB,KAAKD,MAAK,+BAAAnB,OAA8BsB,IAGtF,MAAM,SAAEZ,EAAQ,IAAEC,GAAQa,EAAAA,GAAkB3D,IAAI0B,EAAY,GACtDM,EAASN,EAAWM,OAC1B,IAAI4B,EAAS,EACTC,EAAS,GACb,MAAMC,EAAuBV,EAAYW,wBAAwBlB,GACjE,IAAImB,EAEJ,OADAvB,EAAM,oBAADN,OAAqBsB,EAAI,eAAAtB,OAAcU,EAAQ,UAAAV,OAASW,IAC5C,SAATW,GAA+B,MAAZA,EAAK,GAAa,KAAOA,GAChD,IAAK,KACL,IAAK,OACL,IAAK,MACL,IAAK,OACL,IAAK,OACL,IAAK,OACL,IAAK,MACL,IAAK,OAAQ,CACT,IAAIQ,EACJ,IACIA,EAAOb,EAAYc,gBAAgBlD,EAAAA,GAAkBU,EAAWK,SAAS,GAAIc,GACjF,CACA,MAAOsB,GACH,GAAIA,aAAiBC,MAAO,CACxBb,KAAK5B,iBAAiBO,WAAW,SAADC,OAAUoB,KAAKD,MAAK,UAAAnB,OAASsB,EAAI,sCAAAtB,OAAqCgC,EAAME,UAC5G,KACJ,CACA,MAAMF,CACV,CACA,OAAQV,GACJ,IAAK,OACL,IAAK,OACL,IAAK,OACDI,EAAST,EAAYkB,aAAaf,KAAKgB,WAAWd,EAAMQ,IACxD,MACJ,IAAK,MACL,IAAK,OACL,IAAK,OACL,IAAK,OACL,IAAK,OACL,IAAK,OACDJ,EAASI,EACT,MACJ,IAAK,OACL,IAAK,OACL,IAAK,OACL,IAAK,OACL,IAAK,OACL,IAAK,OAEDJ,EAASN,KAAKgB,WAAWd,EAAMQ,GAC/B,MACJ,IAAK,MACL,IAAK,OACDJ,EAASN,KAAKgB,WAAWd,EAAMQ,GAAMO,IAAIC,GAtH1D,SAAoBC,GAEvB,MAAMC,EAAS,GACf,IAAI3B,EACA4B,EAAO,GACX,IAAK,MAAMC,KAAKH,EACZ,GAAoB,kBAAT1B,EACP,GAAU,MAAN6B,GAAsB,KAAT7B,EACb4B,GAAQ,IACR5B,OAAOxC,OAEN,GAAU,MAANqE,EAAW,CACH,KAATD,IACAD,EAAOG,KAAKF,GACZA,EAAO,IAEX,MAAMG,EAAQhC,EAAeC,GACzB+B,GACAJ,EAAOG,KAAKC,GAEhB/B,OAAOxC,CACX,MAEIwC,GAAQ6B,MAED,MAANA,EACL7B,EAAO,GAGP4B,GAAQC,EAWhB,OARID,IACsB,IAAlBD,EAAO3C,QAAgB4C,EAAK3C,MAAM,WAClC2C,EAAO7B,EAAe6B,IAEtBA,GACAD,EAAOG,KAAKF,IAGbD,CACX,CA6EsEK,CAAWP,IAAIQ,OAAO,CAACC,EAAKC,IAAQD,EAAI/C,OAAOgD,GAAM,IACnG,MACJ,IAAK,MACL,IAAK,OAEDtB,EAASN,KAAKD,OAAS,EAAIC,KAAKgB,WAAWd,EAAMQ,GAAQ,CAACA,GAC1DJ,EAAUuB,MAAMC,QAAQxB,IAAyB,KAAdA,EAAO,GAAa,EAAI,EAC3D,MACJ,QACIA,EAASN,KAAKD,OAAS,EAAIC,KAAKgB,WAAWd,EAAMQ,GAAQ,CAACA,GAElE,KACJ,CACA,IAAK,OAAQ,CACT,MAAMqB,EAAYlC,EAAYmC,sBAAsB7D,EAAWK,SAAS,GAAIc,GAC5EgB,EAAS,CACL2B,YAAaF,EAAUzD,GACvBoC,KAAMV,KAAKgB,WAAWd,EAAMzC,EAAAA,GAAkBsE,EAAUG,KAAM5C,GAAU6C,QAAQ,SAAU,MAE9F,KACJ,CACA,IAAK,MACL,IAAK,OACD,GAAIhC,EAAe,CACf,MAAMiC,EAAM,CAAC,EAEb,OADAjE,EAAaA,EAAWK,SAAS,GACzBwB,KAAKD,OACT,KAAK,EACDqC,EAAIxE,OAASH,EAAAA,GAAkBU,EAAWK,SAAS,EAAG,GAAI,UAC1DL,EAAaA,EAAWK,SAAS,GACjC,MACJ,KAAK,EACL,KAAK,EACDiC,EAAQhD,EAAAA,GAAcU,EAAYiB,GAClCgD,EAAIxE,OAASH,EAAAA,GAAkBU,EAAWK,SAAS,EAAGiC,GAAQrB,GAC9DjB,EAAaA,EAAWK,SAASiC,EAAQ,GACzC,MACJ,QACI,MA2S5B,SAAyCtD,GACrC,MAAM,IAAI8B,EAAkB,wBAADL,OAAyBzB,GACxD,CA7SkCC,CAAgC4C,KAAKD,OAEnDqC,EAAIxE,OAASiC,EAAYwC,mBAAmBD,EAAIxE,QAChDwE,EAAIlC,KAAOoC,EAAAA,GAAoBnE,EAAW,IAC1CA,EAAaA,EAAWK,SAAS,GACjCiC,EAAQhD,EAAAA,GAAcU,EAAYmB,GAClC8C,EAAIH,YAAcxE,EAAAA,GAAkBU,EAAWK,SAAS,EAAGiC,GAAQnB,GACnEnB,EAAaA,EAAWK,SAASiC,EAAQF,GACzC6B,EAAIF,KAAO/D,EACXmC,EAAS8B,CACb,CACA,MACJ,IAAK,MACL,IAAK,OACD9B,GAASiC,EAAAA,EAAAA,IAAapE,GACtB,MACJ,IAAK,OAAQ,CACT,MAAMqE,EAAaC,EAAAA,GAAehG,IAAI0B,EAAY,GAClDA,EAAaA,EAAWK,SAASiE,EAAAA,GAAeC,KAChD,MAAMC,EAAS,CACXC,WAAY,GACZC,SAAUL,EAAWK,SACrBC,YAAaN,EAAWM,YACxBC,gBAAiBP,EAAWO,gBAC5BC,SAAU,IAEd,IAAIC,GAAgB,EACpB,KAAO9E,EAAWM,OAAS,GAAG,CAC1B,MAAMyE,EAAUrD,EAAYsD,yBAAyBhF,EAAYqE,EAAWlD,UAE5E,GADAnB,EAAaA,EAAWK,SAAS0E,EAAQR,KACrCO,EAAe,CACf,MAAMG,EAAYvG,EAAAA,UAAgBJ,IAAI0B,EAAY,GAClDA,EAAaA,EAAWK,SAAS3B,EAAAA,UAAgB6F,KACjDC,EAAOK,SAASzB,KAAK,CACjBb,KAAMwC,EAAQxC,KACd0C,aAER,MAEIT,EAAOC,WAAaM,EAAQxC,KAC5BuC,GAAgB,CAExB,CACA3C,EAASqC,EACT,KACJ,CACA,IAAK,MACL,IAAK,OACL,IAAK,MACL,IAAK,OAAQ,CACT,MAAMU,EAAaC,EAAAA,GAAW7G,IAAI0B,EAAYkC,GAC9CA,GAAUiD,EAAAA,GAAWZ,IACrB,MAAMa,EAAgB1D,EAAYsD,yBAAyBhF,EAAWK,SAAS6B,GAASgD,EAAW/D,UACnGe,GAAUkD,EAAcb,IACxB,MAAMc,EAAU3D,EAAYsD,yBAAyBhF,EAAWK,SAAS6B,GAASgD,EAAW/D,UAM7FgB,EALgB,CACZuC,SAAUQ,EAAWR,SACrBD,WAAYW,EAAc7C,KAC1BA,KAAM8C,EAAQ9C,MAGlB,KACJ,CACA,IAAK,OAAQ,CACT,MAAM+C,EAAO5D,EAAYmC,sBAAsB7D,EAAYiB,GAC3DkB,EAAS,CAAEoD,iBAAkBD,EAAKnF,GAAIqF,WAAYF,EAAKvB,MACvD,KACJ,CACA,IAAK,OAAQ,CACT,MAAM0B,EAAO/D,EAAYmC,sBAAsB7D,EAAYiB,GAC3DkB,EAAS,CAAEoD,iBAAkBE,EAAKtF,GAAI4D,KAAM0B,EAAK1B,MACjD,KACJ,CACA,IAAK,OAAQ,CACT/D,EAAaA,EAAWK,SAAS6B,GACjC,MAAMwD,EAAWhE,EAAYsD,yBAAyBhF,EAAYkB,GAC5DyE,EAAQD,EAASnD,KAEvB,GAA0B,KAD1BvC,EAAaA,EAAWK,SAASqF,EAASnB,MAC3BjE,OAAc,CACzBuB,KAAK5B,iBAAiBO,WAAW,SAADC,OAAUoB,KAAKD,MAAK,UAAAnB,OAASsB,EAAI,oCACjEI,EAAS,CAAEwD,QAAOC,OAAQ,EAAGC,aAAS/G,GACtC,KACJ,CACA,MAAM8G,EAASlH,EAAAA,MAAYJ,IAAI0B,EAAY,GACrC8F,EAAe9F,EAAWK,SAAS3B,EAAAA,MAAY6F,KACrDpC,EAAS,CACLwD,QACAC,SACAC,QAASC,EAAaxF,OAAS,GAAI8D,EAAAA,EAAAA,IAAa0B,QAAgBhH,GAEpE,KACJ,CACA,IAAK,OAAQ,CAET,MAAMqC,EAAWc,EAAAA,GAAkB3D,IAAI0B,EAAY,GACnDA,EAAaA,EAAWK,SAAS,GACjC,MAAM0F,EAAcrE,EAAYsD,yBAAyBhF,EAAYkB,GAC/D8E,EAAWD,EAAYxD,KAC7BvC,EAAaA,EAAWK,SAAS0F,EAAYxB,KAC7C,MAAM0B,EAAcvE,EAAYsD,yBAAyBhF,EAAYmB,GAC/D+E,EAAWD,EAAY1D,KAC7BvC,EAAaA,EAAWK,SAAS4F,EAAY1B,KAC7C,MAAM4B,EAAiBzE,EAAYsD,yBAAyBhF,EAAYmB,GASxEgB,EANa,CACTJ,KAAMiE,EACNE,WACApC,YALgBqC,EAAe5D,KAM/BwB,KALJ/D,EAAaA,EAAWK,SAAS8F,EAAe5B,MAQhD,KACJ,CAEA,IAAK,OACL,IAAK,OACL,IAAK,OACL,IAAK,OACL,IAAK,OACL,IAAK,OACL,IAAK,OACL,IAAK,OAEDpC,EAAST,EAAYsD,yBAAyBhF,EAAYkB,GAAQqB,KAClE,MACJ,IAAK,OAAQ,CAET,MAAMpB,EAAWc,EAAAA,GAAkB3D,IAAI0B,EAAY,GACnDA,EAAaA,EAAWK,SAAS,GACjC,MAAM8F,EAAiBzE,EAAYsD,yBAAyBhF,EAAYmB,GAClE2C,EAAcqC,EAAe5D,KACnCvC,EAAaA,EAAWK,SAAS8F,EAAe5B,KAEhDpC,EAAS,CAAE2B,cAAasC,IAAK1E,EAAYc,gBAAgBlD,EAAAA,GAAkBU,EAAYiB,KACvF,KACJ,CACA,IAAK,MACL,IAAK,OAAQ,CACT,MAAME,EAAWc,EAAAA,GAAkB3D,IAAI0B,EAAY,GACnDA,EAAaA,EAAWK,SAAS,GACjC8B,EAAST,EAAYsD,yBAAyBhF,EAAYmB,GAAUoB,KACpE,KACJ,CACA,IAAK,OAEDJ,EAASnC,EAAWK,SAAS,EAAGC,GAChC,MAIJ,IAAK,OAAQ,CACTS,EAAM,gBACNuB,EAAQhD,EAAAA,GAAcU,EAAYiB,GAClC,MAAMoF,EAAU,CACZC,MAAOhH,EAAAA,GAAkBU,EAAWK,SAAS,EAAGiC,GAAQrB,GACxDsF,KAAMlI,EAAgB2B,EAAYsC,EAAQ,GAC1CkE,OAAQ,IAAIC,KAGhB,IADAvE,GAAUI,EAAQ,EAAIjE,EACf6D,EAAS5B,GAAQ,CACpB,MAAMoG,EAAW3G,EAAgBC,EAAWK,SAAS6B,GAASL,KAAKD,MAAOC,KAAK5B,kBAE/EiC,GADmBnD,EAAqB8C,KAAKD,OAE7C,MAAM+E,EAAY9E,KAAKC,SAAS9B,EAAWK,SAAS6B,EAAQA,EAASwE,EAASpG,QAASoG,EAASvG,GAAI6B,GACpGE,GAAUwE,EAASpG,OACnB+F,EAAQG,OAAOI,IAAIF,EAASvG,GAAIwG,EACpC,CACAxE,EAASkE,EACT,KACJ,CAGA,IAAK,OAAQ,CACTtF,EAAM,gBAEN,MAAM8F,EAAQvH,EAAAA,GAAcU,EAAYiB,GAClCqF,EAAQhH,EAAAA,GAAkBU,EAAWK,SAAS,EAAGwG,GAAQ5F,GAC/DiB,EAAS2E,EAAQ,EAEjB,MAAMjG,EAAQZ,EAAWkC,KACnB4E,EAA8B,KAAV,EAARlG,GACZmG,EAA6B,KAAV,EAARnG,GAEXoG,EAAahH,EAAWkC,KACxB+E,EAAkB,GACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIF,GAAc9E,EAAS5B,EAAQ4G,IAAK,CACpD,MAAMC,EAAM7H,EAAAA,GAAcU,EAAWK,SAAS6B,GAASjB,GACjDmG,EAAU9H,EAAAA,GAAkBU,EAAWK,SAAS6B,EAAQA,EAASiF,GAAMlG,GAC7EgG,EAAgB7D,KAAKgE,GACrBlF,GAAUiF,EAAM,CACpB,CACA,MAAME,EAAM,CACRf,QACA1F,MAAO,CAAEkG,WAAUC,WACnBE,kBACAT,OAAQ,IAAIC,KAGhB,KAAOvE,EAAS5B,GAAQ,CACpB,MAAMoG,EAAW3G,EAAgBC,EAAWK,SAAS6B,GAASL,KAAKD,MAAOC,KAAK5B,kBAE/EiC,GADmBnD,EAAqB8C,KAAKD,OAE7C,MAAM+E,EAAY9E,KAAKC,SAAS9B,EAAWK,SAAS6B,EAAQA,EAASwE,EAASpG,QAASoG,EAASvG,GAAI6B,GACpGE,GAAUwE,EAASpG,OACnB+G,EAAIb,OAAOI,IAAIF,EAASvG,GAAIwG,EAChC,CACAxE,EAASkF,EACT,KACJ,CACA,QACItG,EAAM,wCAADN,OAAyCsB,IAGtD,OAAOI,CACX,CACA,+BAAO6C,CAAyBhF,EAAYmB,GACxC,MAAMmG,EAAUnG,EAASC,IAAM,EAAI,EAC7BmG,EAAcvH,EAAWM,OACzBkH,EAAaxH,EAAWK,SAASiH,GACjCG,EAAYnI,EAAAA,GAAckI,EAAYrG,EAASA,UACrD,GAAIsG,GAAaD,EAAWlH,OAExB,MAAO,CACHiC,KAAMjD,EAAAA,GAAkBkI,EAAYrG,EAASA,UAC7CoD,IAAKgD,GAGb,MAAMG,EAAMF,EAAWnH,SAAS,EAAGoH,GACnC,MAAO,CACHlF,KAAMjD,EAAAA,GAAkBoI,EAAKvG,EAASA,UACtCoD,IAAK+C,EAAUG,EAAY/F,EAAYW,wBAAwBlB,EAASA,UAEhF,CACA,yBAAO+C,CAAmByD,GAEtB,OADAA,EAAcA,EAAYC,qBAEtB,IAAK,MACD,MAAO,aACX,IAAK,MACD,MAAO,YAEf,OAAOD,CACX,CAKA,mBAAO/E,CAAaiF,GAChB,MAAMC,EAAM,CAAC,EACb,IAAK,IAAIZ,EAAI,EAAGA,EAAI,EAAIW,EAAQvH,OAAQ4G,GAAK,EAAG,CAC5C,MAAMa,EAAQF,EAAQX,EAAI,GAAGc,MAAM,KACnCF,EAAID,EAAQX,IAAMY,EAAID,EAAQX,IAAMY,EAAID,EAAQX,IAAIzG,OAAOsH,GAASA,CACxE,CACA,OAAOD,CACX,CAQAjF,UAAAA,CAAWoF,EAAK1F,GACZ,IAAI2F,EAaJ,OAZIrG,KAAKD,MAAQ,GACbsG,EAAS3F,EAAKyF,MAAM,SAChBE,EAAO5H,OAAS,EAChBuB,KAAK5B,iBAAiBO,WAAW,SAADC,OAAUoB,KAAKD,MAAK,KAAAnB,OAAIwH,EAAG,uCAG3DC,EAAS3F,EAAKyF,MAAM,QAIxBE,EAAS3F,EAAKyF,MAAM,SAEjBtG,EAAYyG,UAAUD,EACjC,CACA,gBAAOC,CAAUD,GACb,OAAOA,EAAOpF,IAAIsF,GAAS1G,EAAYc,gBAAgB4F,GAAOC,OAClE,CACA,sBAAO7F,CAAgB4F,GACnB,IAAIjB,EAAMiB,EAAM9H,OAChB,KAAO6G,EAAM,GAAmC,IAA9BiB,EAAME,WAAWnB,EAAM,IACrCA,IAEJ,OAAOA,IAAQiB,EAAM9H,OAAS8H,EAAQA,EAAMG,MAAM,EAAGpB,EACzD,CACA,4BAAOtD,CAAsB7D,EAAYmB,GACrC,MAAMqH,EAAQ9G,EAAYsD,yBAAyBhF,EAAY,CAAEmB,WAAUC,KAAK,IAChF,MAAO,CAAEjB,GAAIqI,EAAMjG,KAAMwB,KAAM/D,EAAWK,SAASmI,EAAMjE,KAC7D,CACA,8BAAOlC,CAAwBoG,GAC3B,OAAOA,EAAIC,WAAW,UAAY,EAAI,CAC1C,EAEG,MAAM5H,WAA0B6H,EAAAA,EAAAA,IAA+B,WC7c/D,MAAMC,EACTjH,WAAAA,GACIE,KAAKgH,eAAY/J,EACjB+C,KAAKiH,eAAYhK,EACjB+C,KAAKkH,cAAWjK,EAChB+C,KAAKmH,gBAAalK,EAClB+C,KAAKoH,aAAUnK,CACnB,CACA,wBAAOoK,CAAkBC,GACrB,IAAIC,EAAQ,EACRC,EAAS,EACb,KAAOD,EAAQD,EAAO7I,OAAS,GACvB8I,IAAUC,IACVF,EAAOE,GAAUF,EAAOC,IAE5BA,GAA4B,MAAlBD,EAAOC,IAAyC,IAAtBD,EAAOC,EAAQ,GAAY,EAAI,EACnEC,IAKJ,OAHID,EAAQD,EAAO7I,SACf6I,EAAOE,KAAYF,EAAOC,IAEvBD,EAAO9I,SAAS,EAAGgJ,EAC9B,CACA,oBAAOC,CAActJ,EAAYuJ,EAAavK,EAAUgD,EAAe/B,GAAkB,IAAAuJ,EAAAC,EACrF,MAAMC,EAAc,IAAIhI,EAAY1C,EAAUiB,GAC9C,OAAQjB,GACJ,KAAK,EACD,OAAO0K,EAAY5H,SAAS9B,EAAYuJ,EAAYpJ,GAAI6B,GAC5D,KAAK,EACL,KAAK,EAOD,OANqB,QAArBwH,EAAID,EAAY3I,aAAK,IAAA4I,GAAjBA,EAAmB/J,OAAOI,oBAC1BG,EAAa4I,EAAYM,kBAAkBlJ,IAE1B,QAArByJ,EAAIF,EAAY3I,aAAK,IAAA6I,GAAjBA,EAAmBhK,OAAOK,wBAC1BE,EAAaA,EAAWK,SAAS,EAAGL,EAAWM,SAE5CoJ,EAAY5H,SAAS9B,EAAYuJ,EAAYpJ,GAAI6B,GAC5D,QACI,MA4HhB,SAAyChD,GACrC,MAAM,IAAI8B,EAAkB,wBAADL,OAAyBzB,GACxD,CA9HsBC,CAAgCD,GAElD,CAOA,6BAAO2K,CAAuB1B,EAAKnE,GAC/B,OAAOmE,GAAOnE,EAAc,IAAHrD,OAAOqD,GAAgB,GACpD,CACA,WAAM8F,CAAMb,EAAUF,EAAWI,GAC7BpH,KAAKgH,UAAYA,EACjBhH,KAAKkH,SAAWA,EAChBlH,KAAKoH,QAAUA,EACf,MAAMH,QAAkBjH,KAAKgH,UAAUgB,UAAUC,EAAAA,IACjD,GAAiC,QAA7BhB,EAAUiB,eACV,MAAM,IAAIjJ,EAAkB,2DAEhCe,KAAKiH,UAAYA,EACjBjH,KAAKmH,WAAa,SAAHvI,OAAaqI,EAAUkB,QAAQpI,aACvCkH,EAAUlI,MAAMqJ,iBAAmBpI,KAAKqI,sBAAwBrI,KAAKsI,aAAarB,EAAUsB,OAEnG,MAAMC,EAAWzB,EAAY0B,iBAAiBzI,KAAKkH,SAASwB,OAAO1I,KAAKmH,aACxEnH,KAAKkH,SAASyB,UAAU,WAAYH,EACxC,CACA,yBAAMH,GACF,MAAMO,QAAuB5I,KAAKgH,UAAUgB,UAAUa,EAAAA,IAChDC,EAAgBF,EAAeL,KAAOM,EAAAA,GAAenG,IAC3D,OAAOoG,EAAgB,EAAI9I,KAAK+I,wBAAwBD,EAAeF,EAAeL,MAAQvI,KAAKsI,aAAatI,KAAKiH,UAAUsB,KAAOK,EAAeL,KACzJ,CACA,6BAAMQ,CAAwBD,EAAeE,GAEzC,aADMhJ,KAAKgH,UAAUiC,OAAOH,GACrB9I,KAAKsI,aAAatI,KAAKiH,UAAUsB,KAAOS,EACnD,CACA,kBAAMV,CAAaY,GACf,MAAM/K,QAAmB6B,KAAKgH,UAAUgB,UAAU,IAAInL,EAAAA,eAAqBqM,IAC3E,IAAK,MAAM9C,KAAOpG,KAAKmJ,cAAchL,GACjC,GACS,SADDiI,EAAI9H,GAEA8H,EAAIG,aACEvG,KAAKoJ,UAAUhD,EAAKA,EAAIG,MAAM7F,KAAM,IAAM0F,EAAIG,MAAMtE,wBAIvDJ,MAAMC,QAAQsE,EAAIG,OAAS8C,QAAQC,IAAIlD,EAAIG,MAAMtF,IAAIsF,GAASvG,KAAKuJ,OAAOnD,EAAI9H,GAAIiI,KAAWvG,KAAKuJ,OAAOnD,EAAI9H,GAAI8H,EAAIG,OAG5I,CACA,eAAM6C,CAAUhD,EAAKC,EAAQzD,GAA2C,IAA/B4G,EAAYC,UAAAhL,OAAA,QAAAxB,IAAAwM,UAAA,GAAAA,UAAA,GAAGlD,GAASA,QACvD8C,QAAQC,IAAIjD,EAAOpF,IAAIsF,GAASvG,KAAKuJ,OAAOxC,EAAYe,uBAAuB1B,EAAI9H,GAAIsE,EAAW2D,IAASiD,EAAajD,KAClI,CACA,YAAMgD,CAAOjL,EAAIiI,SACPvG,KAAKkH,SAASqC,OAAOvJ,KAAKmH,WAAY7I,EAAIiI,EACpD,CACA4C,aAAAA,CAAcjH,GACV,IAAI7B,EAAS,EACb,MAAMqJ,EAAO,GACb,KACQrJ,IAAW6B,EAAKzD,QADX,CAGT,MAAMkL,EAAoBzM,EAAqB8C,KAAKiH,UAAUkB,QAAQpI,OACtE,GAAIM,EAASsJ,EAAoBzH,EAAKzD,OAAQ,CAC1CuB,KAAKkH,SAASvI,WAAW,4BACzB,KACJ,CACA,MAAMiL,EAAmB1H,EAAK1D,SAAS6B,EAAQA,EAASsJ,GACxDtJ,GAAUsJ,EACV,MAAMjC,EAAcxJ,EAAgB0L,EAAkB5J,KAAKiH,UAAUkB,QAAQpI,MAAOC,KAAKkH,UACnF2C,EAAiB3H,EAAK1D,SAAS6B,EAAQA,EAASqH,EAAYjJ,QAClE4B,GAAUqH,EAAYjJ,OACtB,MAAM4H,EAASU,EAAYU,cAAcoC,EAAgBnC,EAAa1H,KAAKiH,UAAUkB,QAAQpI,OAAQC,KAAKoH,QAAQ0C,WAAY9J,KAAKkH,UAC/Hb,GACAqD,EAAKnI,KAAK,CAAEjD,GAAIoJ,EAAYpJ,GAAIiI,MAAOF,GAE/C,CACA,OAAOqD,CACX,CAOA,uBAAOjB,CAAiBsB,GACpB,IAAKA,EACD,OACJ,MAAMC,EAAaD,EAAQE,OAAOC,GAAc,SAATA,EAAE5L,IACzC,GAAe,OAAV0L,QAAU,IAAVA,IAAAA,EAAYvL,OACb,OACJ,MAAM0L,EAAYJ,EAAQE,OAAOC,GAAc,SAATA,EAAE5L,IAClC8L,EAAuB,OAATD,QAAS,IAATA,OAAS,EAATA,EAAWE,KAAKH,IAAC,IAAAI,EAAA,OAAiB,QAAjBA,EAAIJ,EAAE3D,MAAMxH,aAAK,IAAAuL,OAAA,EAAbA,EAAerF,WAClDsF,EAAc,IAAI3F,IACxB,IAAK,MAAM4F,KAAQR,EACfO,EAAYxF,IAAIyF,EAAKjE,MAAM9B,MAAO+F,EAAKjE,OAE3C,MAAMkE,EAAwB,OAAXL,QAAW,IAAXA,OAAW,EAAXA,EAAa7D,MAAMnB,gBAChCoD,EAAW,GACXkC,EAAmB,OAAVD,QAAU,IAAVA,EAAAA,EAAc,IAAIF,EAAYI,QAC7C,IAAK,MAAMrM,KAAMoM,EAAQ,CACrB,MAAMF,EAAOD,EAAY9N,IAAI6B,GAC7B,IAAKkM,EACD,SACJ,MAAM7F,EAAS6F,EAAK7F,OACdiG,EAAQjG,EAAOlI,IAAI,QACpBmO,GAELpC,EAASjH,KAAK,CACVjD,KACAsM,QACArG,IAAKI,EAAOlI,IAAI,QAChBoO,MAAOL,EAAK9F,KAAK3H,UAAY,IAC7BuI,IAAKkF,EAAK9F,KAAK1H,QAAU,IACzB8N,MAAOnG,EAAOlI,IAAI,SAE1B,CAKA,OAHKgO,GACDjC,EAASuC,KAAK,CAACC,EAAG1N,IAAM0N,EAAEH,MAAQvN,EAAEuN,OAEjCrC,EAAS/J,OAAS+J,OAAWvL,CACxC,E","sources":["../node_modules/music-metadata/lib/id3v2/ID3v2ChapterToken.js","../node_modules/music-metadata/lib/id3v2/FrameHeader.js","../node_modules/music-metadata/lib/id3v2/FrameParser.js","../node_modules/music-metadata/lib/id3v2/ID3v2Parser.js"],"sourcesContent":["import * as Token from 'token-types';\n/**\n * Data portion of `CHAP` sub frame\n */\nexport const ChapterInfo = {\n    len: 16,\n    get: (buf, off) => {\n        const startOffset = Token.UINT32_BE.get(buf, off + 8);\n        const endOffset = Token.UINT32_BE.get(buf, off + 12);\n        return {\n            startTime: Token.UINT32_BE.get(buf, off),\n            endTime: Token.UINT32_BE.get(buf, off + 4),\n            startOffset: startOffset === 0xFFFFFFFF ? undefined : startOffset,\n            endOffset: endOffset === 0xFFFFFFFF ? undefined : endOffset,\n        };\n    }\n};\n","// lib/id3v2/FrameHeader.ts\nimport * as Token from 'token-types';\nimport * as util from '../common/Util.js';\nimport { UINT32SYNCSAFE } from './ID3v2Token.js';\nimport { textDecode } from '@borewit/text-codec';\nimport { Id3v2ContentError } from './FrameParser.js';\n/**\n * Frame header length (bytes) depending on ID3v2 major version.\n */\nexport function getFrameHeaderLength(majorVer) {\n    switch (majorVer) {\n        case 2: return 6;\n        case 3:\n        case 4: return 10;\n        default: throw makeUnexpectedMajorVersionError(majorVer);\n    }\n}\nfunction readFrameFlags(b) {\n    return {\n        status: {\n            tag_alter_preservation: util.getBit(b, 0, 6),\n            file_alter_preservation: util.getBit(b, 0, 5),\n            read_only: util.getBit(b, 0, 4)\n        },\n        format: {\n            grouping_identity: util.getBit(b, 1, 7),\n            compression: util.getBit(b, 1, 3),\n            encryption: util.getBit(b, 1, 2),\n            unsynchronisation: util.getBit(b, 1, 1),\n            data_length_indicator: util.getBit(b, 1, 0)\n        }\n    };\n}\n/**\n * Factory: parse a frame header from its header bytes (6 for v2.2, 10 for v2.3/v2.4).\n *\n * Note: It only *parses* and does light validation. It does not read payload bytes.\n */\nexport function readFrameHeader(uint8Array, majorVer, warningCollector) {\n    switch (majorVer) {\n        case 2:\n            return parseFrameHeaderV22(uint8Array, majorVer, warningCollector);\n        case 3:\n        case 4:\n            return parseFrameHeaderV23V24(uint8Array, majorVer, warningCollector);\n        default:\n            throw makeUnexpectedMajorVersionError(majorVer);\n    }\n}\nfunction parseFrameHeaderV22(uint8Array, majorVer, warningCollector) {\n    const header = {\n        id: textDecode(uint8Array.subarray(0, 3), 'ascii'),\n        length: Token.UINT24_BE.get(uint8Array, 3)\n    };\n    if (!header.id.match(/^[A-Z0-9]{3}$/)) {\n        warningCollector.addWarning(`Invalid ID3v2.${majorVer} frame-header-ID: ${header.id}`);\n    }\n    return header;\n}\nfunction parseFrameHeaderV23V24(uint8Array, majorVer, warningCollector) {\n    const header = {\n        id: textDecode(uint8Array.subarray(0, 4), 'ascii'),\n        length: (majorVer === 4 ? UINT32SYNCSAFE : Token.UINT32_BE).get(uint8Array, 4),\n        flags: readFrameFlags(uint8Array.subarray(8, 10))\n    };\n    if (!header.id.match(/^[A-Z0-9]{4}$/)) {\n        warningCollector.addWarning(`Invalid ID3v2.${majorVer} frame-header-ID: ${header.id}`);\n    }\n    return header;\n}\nfunction makeUnexpectedMajorVersionError(majorVer) {\n    throw new Id3v2ContentError(`Unexpected majorVer: ${majorVer}`);\n}\n","import initDebug from 'debug';\nimport * as Token from 'token-types';\nimport * as util from '../common/Util.js';\nimport { AttachedPictureType, SyncTextHeader, TextEncodingToken, TextHeader } from './ID3v2Token.js';\nimport { Genres } from '../id3v1/ID3v1Parser.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport { decodeUintBE } from '../common/Util.js';\nimport { ChapterInfo } from './ID3v2ChapterToken.js';\nimport { getFrameHeaderLength, readFrameHeader } from './FrameHeader.js';\nconst debug = initDebug('music-metadata:id3v2:frame-parser');\nconst defaultEnc = 'latin1'; // latin1 == iso-8859-1;\nconst urlEnc = { encoding: defaultEnc, bom: false };\nexport function parseGenre(origVal) {\n    // match everything inside parentheses\n    const genres = [];\n    let code;\n    let word = '';\n    for (const c of origVal) {\n        if (typeof code === 'string') {\n            if (c === '(' && code === '') {\n                word += '(';\n                code = undefined;\n            }\n            else if (c === ')') {\n                if (word !== '') {\n                    genres.push(word);\n                    word = '';\n                }\n                const genre = parseGenreCode(code);\n                if (genre) {\n                    genres.push(genre);\n                }\n                code = undefined;\n            }\n            else\n                code += c;\n        }\n        else if (c === '(') {\n            code = '';\n        }\n        else {\n            word += c;\n        }\n    }\n    if (word) {\n        if (genres.length === 0 && word.match(/^\\d*$/)) {\n            word = parseGenreCode(word);\n        }\n        if (word) {\n            genres.push(word);\n        }\n    }\n    return genres;\n}\nfunction parseGenreCode(code) {\n    if (code === 'RX')\n        return 'Remix';\n    if (code === 'CR')\n        return 'Cover';\n    if (code.match(/^\\d*$/)) {\n        return Genres[Number.parseInt(code, 10)];\n    }\n}\nexport class FrameParser {\n    /**\n     * Create id3v2 frame parser\n     * @param major - Major version, e.g. (4) for  id3v2.4\n     * @param warningCollector - Used to collect decode issue\n     */\n    constructor(major, warningCollector) {\n        this.major = major;\n        this.warningCollector = warningCollector;\n    }\n    readData(uint8Array, type, includeCovers) {\n        if (uint8Array.length === 0) {\n            this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);\n            return;\n        }\n        const { encoding, bom } = TextEncodingToken.get(uint8Array, 0);\n        const length = uint8Array.length;\n        let offset = 0;\n        let output = []; // ToDo\n        const nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);\n        let fzero;\n        debug(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`);\n        switch (type !== 'TXXX' && type[0] === 'T' ? 'T*' : type) {\n            case 'T*': // 4.2.1. Text information frames - details\n            case 'GRP1': // iTunes-specific ID3v2 grouping field\n            case 'GP1': // iTunes-specific ID3v2.2 grouping field\n            case 'IPLS': // v2.3: Involved people list\n            case 'MVIN':\n            case 'MVNM':\n            case 'PCS':\n            case 'PCST': {\n                let text;\n                try {\n                    text = FrameParser.trimNullPadding(util.decodeString(uint8Array.subarray(1), encoding));\n                }\n                catch (error) {\n                    if (error instanceof Error) {\n                        this.warningCollector.addWarning(`id3v2.${this.major} type=${type} header has invalid string value: ${error.message}`);\n                        break;\n                    }\n                    throw error;\n                }\n                switch (type) {\n                    case 'TMCL': // Musician credits list\n                    case 'TIPL': // Involved people list\n                    case 'IPLS': // Involved people list\n                        output = FrameParser.functionList(this.splitValue(type, text));\n                        break;\n                    case 'TRK':\n                    case 'TRCK':\n                    case 'TPOS':\n                    case 'TIT1':\n                    case 'TIT2':\n                    case 'TIT3':\n                        output = text;\n                        break;\n                    case 'TCOM':\n                    case 'TEXT':\n                    case 'TOLY':\n                    case 'TOPE':\n                    case 'TPE1':\n                    case 'TSRC':\n                        // id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\n                        output = this.splitValue(type, text);\n                        break;\n                    case 'TCO':\n                    case 'TCON':\n                        output = this.splitValue(type, text).map(v => parseGenre(v)).reduce((acc, val) => acc.concat(val), []);\n                        break;\n                    case 'PCS':\n                    case 'PCST':\n                        // TODO: Why `default` not results `1` but `''`?\n                        output = this.major >= 4 ? this.splitValue(type, text) : [text];\n                        output = (Array.isArray(output) && output[0] === '') ? 1 : 0;\n                        break;\n                    default:\n                        output = this.major >= 4 ? this.splitValue(type, text) : [text];\n                }\n                break;\n            }\n            case 'TXXX': {\n                const idAndData = FrameParser.readIdentifierAndData(uint8Array.subarray(1), encoding);\n                output = {\n                    description: idAndData.id,\n                    text: this.splitValue(type, util.decodeString(idAndData.data, encoding).replace(/\\x00+$/, ''))\n                };\n                break;\n            }\n            case 'PIC':\n            case 'APIC':\n                if (includeCovers) {\n                    const pic = {};\n                    uint8Array = uint8Array.subarray(1);\n                    switch (this.major) {\n                        case 2:\n                            pic.format = util.decodeString(uint8Array.subarray(0, 3), 'latin1'); // 'latin1'; // latin1 == iso-8859-1;\n                            uint8Array = uint8Array.subarray(3);\n                            break;\n                        case 3:\n                        case 4:\n                            fzero = util.findZero(uint8Array, defaultEnc);\n                            pic.format = util.decodeString(uint8Array.subarray(0, fzero), defaultEnc);\n                            uint8Array = uint8Array.subarray(fzero + 1);\n                            break;\n                        default:\n                            throw makeUnexpectedMajorVersionError(this.major);\n                    }\n                    pic.format = FrameParser.fixPictureMimeType(pic.format);\n                    pic.type = AttachedPictureType[uint8Array[0]];\n                    uint8Array = uint8Array.subarray(1);\n                    fzero = util.findZero(uint8Array, encoding);\n                    pic.description = util.decodeString(uint8Array.subarray(0, fzero), encoding);\n                    uint8Array = uint8Array.subarray(fzero + nullTerminatorLength);\n                    pic.data = uint8Array;\n                    output = pic;\n                }\n                break;\n            case 'CNT':\n            case 'PCNT':\n                output = decodeUintBE(uint8Array);\n                break;\n            case 'SYLT': {\n                const syltHeader = SyncTextHeader.get(uint8Array, 0);\n                uint8Array = uint8Array.subarray(SyncTextHeader.len);\n                const result = {\n                    descriptor: '',\n                    language: syltHeader.language,\n                    contentType: syltHeader.contentType,\n                    timeStampFormat: syltHeader.timeStampFormat,\n                    syncText: []\n                };\n                let readSyllables = false;\n                while (uint8Array.length > 0) {\n                    const nullStr = FrameParser.readNullTerminatedString(uint8Array, syltHeader.encoding);\n                    uint8Array = uint8Array.subarray(nullStr.len);\n                    if (readSyllables) {\n                        const timestamp = Token.UINT32_BE.get(uint8Array, 0);\n                        uint8Array = uint8Array.subarray(Token.UINT32_BE.len);\n                        result.syncText.push({\n                            text: nullStr.text,\n                            timestamp\n                        });\n                    }\n                    else {\n                        result.descriptor = nullStr.text;\n                        readSyllables = true;\n                    }\n                }\n                output = result;\n                break;\n            }\n            case 'ULT':\n            case 'USLT':\n            case 'COM':\n            case 'COMM': {\n                const textHeader = TextHeader.get(uint8Array, offset);\n                offset += TextHeader.len;\n                const descriptorStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);\n                offset += descriptorStr.len;\n                const textStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);\n                const comment = {\n                    language: textHeader.language,\n                    descriptor: descriptorStr.text,\n                    text: textStr.text\n                };\n                output = comment;\n                break;\n            }\n            case 'UFID': {\n                const ufid = FrameParser.readIdentifierAndData(uint8Array, defaultEnc);\n                output = { owner_identifier: ufid.id, identifier: ufid.data };\n                break;\n            }\n            case 'PRIV': { // private frame\n                const priv = FrameParser.readIdentifierAndData(uint8Array, defaultEnc);\n                output = { owner_identifier: priv.id, data: priv.data };\n                break;\n            }\n            case 'POPM': { // Popularimeter\n                uint8Array = uint8Array.subarray(offset);\n                const emailStr = FrameParser.readNullTerminatedString(uint8Array, urlEnc);\n                const email = emailStr.text;\n                uint8Array = uint8Array.subarray(emailStr.len);\n                if (uint8Array.length === 0) {\n                    this.warningCollector.addWarning(`id3v2.${this.major} type=${type} POPM frame missing rating byte`);\n                    output = { email, rating: 0, counter: undefined };\n                    break;\n                }\n                const rating = Token.UINT8.get(uint8Array, 0);\n                const counterBytes = uint8Array.subarray(Token.UINT8.len);\n                output = {\n                    email,\n                    rating,\n                    counter: counterBytes.length > 0 ? decodeUintBE(counterBytes) : undefined\n                };\n                break;\n            }\n            case 'GEOB': { // General encapsulated object\n                // [encoding] <MIME> 0x00 <filename> 0x00/0x00 0x00 <description> 0x00/0x00 0x00 <data>\n                const encoding = TextEncodingToken.get(uint8Array, 0);\n                uint8Array = uint8Array.subarray(1);\n                const mimeTypeStr = FrameParser.readNullTerminatedString(uint8Array, urlEnc);\n                const mimeType = mimeTypeStr.text;\n                uint8Array = uint8Array.subarray(mimeTypeStr.len);\n                const filenameStr = FrameParser.readNullTerminatedString(uint8Array, encoding);\n                const filename = filenameStr.text;\n                uint8Array = uint8Array.subarray(filenameStr.len);\n                const descriptionStr = FrameParser.readNullTerminatedString(uint8Array, encoding);\n                const description = descriptionStr.text;\n                uint8Array = uint8Array.subarray(descriptionStr.len);\n                const geob = {\n                    type: mimeType,\n                    filename,\n                    description,\n                    data: uint8Array\n                };\n                output = geob;\n                break;\n            }\n            // W-Frames:\n            case 'WCOM':\n            case 'WCOP':\n            case 'WOAF':\n            case 'WOAR':\n            case 'WOAS':\n            case 'WORS':\n            case 'WPAY':\n            case 'WPUB':\n                // Decode URL\n                output = FrameParser.readNullTerminatedString(uint8Array, urlEnc).text;\n                break;\n            case 'WXXX': {\n                // [encoding] <description> 0x00/0x00 0x00 <url>\n                const encoding = TextEncodingToken.get(uint8Array, 0);\n                uint8Array = uint8Array.subarray(1);\n                const descriptionStr = FrameParser.readNullTerminatedString(uint8Array, encoding);\n                const description = descriptionStr.text;\n                uint8Array = uint8Array.subarray(descriptionStr.len);\n                // URL is always ISO-8859-1\n                output = { description, url: FrameParser.trimNullPadding(util.decodeString(uint8Array, defaultEnc)) };\n                break;\n            }\n            case 'WFD':\n            case 'WFED': {\n                const encoding = TextEncodingToken.get(uint8Array, 0);\n                uint8Array = uint8Array.subarray(1);\n                output = FrameParser.readNullTerminatedString(uint8Array, encoding).text;\n                break;\n            }\n            case 'MCDI': {\n                // Music CD identifier\n                output = uint8Array.subarray(0, length);\n                break;\n            }\n            // ID3v2 Chapters 1.0\n            // https://mutagen-specs.readthedocs.io/en/latest/id3/id3v2-chapters-1.0.html#chapter-frame\n            case 'CHAP': { //  // Chapter frame\n                debug(\"Reading CHAP\");\n                fzero = util.findZero(uint8Array, defaultEnc);\n                const chapter = {\n                    label: util.decodeString(uint8Array.subarray(0, fzero), defaultEnc),\n                    info: ChapterInfo.get(uint8Array, fzero + 1),\n                    frames: new Map()\n                };\n                offset += fzero + 1 + ChapterInfo.len;\n                while (offset < length) {\n                    const subFrame = readFrameHeader(uint8Array.subarray(offset), this.major, this.warningCollector);\n                    const headerSize = getFrameHeaderLength(this.major);\n                    offset += headerSize;\n                    const subOutput = this.readData(uint8Array.subarray(offset, offset + subFrame.length), subFrame.id, includeCovers);\n                    offset += subFrame.length;\n                    chapter.frames.set(subFrame.id, subOutput);\n                }\n                output = chapter;\n                break;\n            }\n            // ID3v2 Chapters 1.0\n            // https://mutagen-specs.readthedocs.io/en/latest/id3/id3v2-chapters-1.0.html#table-of-contents-frame\n            case 'CTOC': { // Table of contents frame\n                debug('Reading CTOC');\n                // Element ID (null-terminated latin1)\n                const idEnd = util.findZero(uint8Array, defaultEnc);\n                const label = util.decodeString(uint8Array.subarray(0, idEnd), defaultEnc);\n                offset = idEnd + 1;\n                // Flags\n                const flags = uint8Array[offset++];\n                const topLevel = (flags & 0x02) !== 0;\n                const ordered = (flags & 0x01) !== 0;\n                // Child element IDs\n                const entryCount = uint8Array[offset++];\n                const childElementIds = [];\n                for (let i = 0; i < entryCount && offset < length; i++) {\n                    const end = util.findZero(uint8Array.subarray(offset), defaultEnc);\n                    const childId = util.decodeString(uint8Array.subarray(offset, offset + end), defaultEnc);\n                    childElementIds.push(childId);\n                    offset += end + 1;\n                }\n                const toc = {\n                    label,\n                    flags: { topLevel, ordered },\n                    childElementIds,\n                    frames: new Map()\n                };\n                // Optional embedded sub-frames (e.g. TIT2) follow after the child list\n                while (offset < length) {\n                    const subFrame = readFrameHeader(uint8Array.subarray(offset), this.major, this.warningCollector);\n                    const headerSize = getFrameHeaderLength(this.major);\n                    offset += headerSize;\n                    const subOutput = this.readData(uint8Array.subarray(offset, offset + subFrame.length), subFrame.id, includeCovers);\n                    offset += subFrame.length;\n                    toc.frames.set(subFrame.id, subOutput);\n                }\n                output = toc;\n                break;\n            }\n            default:\n                debug(`Warning: unsupported id3v2-tag-type: ${type}`);\n                break;\n        }\n        return output;\n    }\n    static readNullTerminatedString(uint8Array, encoding) {\n        const bomSize = encoding.bom ? 2 : 0;\n        const originalLen = uint8Array.length;\n        const valueArray = uint8Array.subarray(bomSize);\n        const zeroIndex = util.findZero(valueArray, encoding.encoding);\n        if (zeroIndex >= valueArray.length) {\n            // No terminator found, decode full buffer remainder\n            return {\n                text: util.decodeString(valueArray, encoding.encoding),\n                len: originalLen\n            };\n        }\n        const txt = valueArray.subarray(0, zeroIndex);\n        return {\n            text: util.decodeString(txt, encoding.encoding),\n            len: bomSize + zeroIndex + FrameParser.getNullTerminatorLength(encoding.encoding)\n        };\n    }\n    static fixPictureMimeType(pictureType) {\n        pictureType = pictureType.toLocaleLowerCase();\n        switch (pictureType) {\n            case 'jpg':\n                return 'image/jpeg';\n            case 'png':\n                return 'image/png';\n        }\n        return pictureType;\n    }\n    /**\n     * Converts TMCL (Musician credits list) or TIPL (Involved people list)\n     * @param entries\n     */\n    static functionList(entries) {\n        const res = {};\n        for (let i = 0; i + 1 < entries.length; i += 2) {\n            const names = entries[i + 1].split(',');\n            res[entries[i]] = res[entries[i]] ? res[entries[i]].concat(names) : names;\n        }\n        return res;\n    }\n    /**\n     * id3v2.4 defines that multiple T* values are separated by 0x00\n     * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\n     * @param tag - Tag name\n     * @param text - Concatenated tag value\n     * @returns Split tag value\n     */\n    splitValue(tag, text) {\n        let values;\n        if (this.major < 4) {\n            values = text.split(/\\x00/g);\n            if (values.length > 1) {\n                this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`);\n            }\n            else {\n                values = text.split(/\\//g);\n            }\n        }\n        else {\n            values = text.split(/\\x00/g);\n        }\n        return FrameParser.trimArray(values);\n    }\n    static trimArray(values) {\n        return values.map(value => FrameParser.trimNullPadding(value).trim());\n    }\n    static trimNullPadding(value) {\n        let end = value.length;\n        while (end > 0 && value.charCodeAt(end - 1) === 0) {\n            end--;\n        }\n        return end === value.length ? value : value.slice(0, end);\n    }\n    static readIdentifierAndData(uint8Array, encoding) {\n        const idStr = FrameParser.readNullTerminatedString(uint8Array, { encoding, bom: false });\n        return { id: idStr.text, data: uint8Array.subarray(idStr.len) };\n    }\n    static getNullTerminatorLength(enc) {\n        return enc.startsWith('utf-16') ? 2 : 1;\n    }\n}\nexport class Id3v2ContentError extends makeUnexpectedFileContentError('id3v2') {\n}\nfunction makeUnexpectedMajorVersionError(majorVer) {\n    throw new Id3v2ContentError(`Unexpected majorVer: ${majorVer}`);\n}\n","import * as Token from 'token-types';\nimport { FrameParser, Id3v2ContentError } from './FrameParser.js';\nimport { ExtendedHeader, ID3v2Header } from './ID3v2Token.js';\nimport { getFrameHeaderLength, readFrameHeader } from './FrameHeader.js';\nexport class ID3v2Parser {\n    constructor() {\n        this.tokenizer = undefined;\n        this.id3Header = undefined;\n        this.metadata = undefined;\n        this.headerType = undefined;\n        this.options = undefined;\n    }\n    static removeUnsyncBytes(buffer) {\n        let readI = 0;\n        let writeI = 0;\n        while (readI < buffer.length - 1) {\n            if (readI !== writeI) {\n                buffer[writeI] = buffer[readI];\n            }\n            readI += (buffer[readI] === 0xFF && buffer[readI + 1] === 0) ? 2 : 1;\n            writeI++;\n        }\n        if (readI < buffer.length) {\n            buffer[writeI++] = buffer[readI];\n        }\n        return buffer.subarray(0, writeI);\n    }\n    static readFrameData(uint8Array, frameHeader, majorVer, includeCovers, warningCollector) {\n        const frameParser = new FrameParser(majorVer, warningCollector);\n        switch (majorVer) {\n            case 2:\n                return frameParser.readData(uint8Array, frameHeader.id, includeCovers);\n            case 3:\n            case 4:\n                if (frameHeader.flags?.format.unsynchronisation) {\n                    uint8Array = ID3v2Parser.removeUnsyncBytes(uint8Array);\n                }\n                if (frameHeader.flags?.format.data_length_indicator) {\n                    uint8Array = uint8Array.subarray(4, uint8Array.length);\n                }\n                return frameParser.readData(uint8Array, frameHeader.id, includeCovers);\n            default:\n                throw makeUnexpectedMajorVersionError(majorVer);\n        }\n    }\n    /**\n     * Create a combined tag key, of tag & description\n     * @param tag e.g.: COM\n     * @param description e.g. iTunPGAP\n     * @returns string e.g. COM:iTunPGAP\n     */\n    static makeDescriptionTagName(tag, description) {\n        return tag + (description ? `:${description}` : '');\n    }\n    async parse(metadata, tokenizer, options) {\n        this.tokenizer = tokenizer;\n        this.metadata = metadata;\n        this.options = options;\n        const id3Header = await this.tokenizer.readToken(ID3v2Header);\n        if (id3Header.fileIdentifier !== 'ID3') {\n            throw new Id3v2ContentError('expected ID3-header file-identifier \\'ID3\\' was not found');\n        }\n        this.id3Header = id3Header;\n        this.headerType = (`ID3v2.${id3Header.version.major}`);\n        await (id3Header.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(id3Header.size));\n        // Post process\n        const chapters = ID3v2Parser.mapId3v2Chapters(this.metadata.native[this.headerType]);\n        this.metadata.setFormat('chapters', chapters);\n    }\n    async parseExtendedHeader() {\n        const extendedHeader = await this.tokenizer.readToken(ExtendedHeader);\n        const dataRemaining = extendedHeader.size - ExtendedHeader.len;\n        return dataRemaining > 0 ? this.parseExtendedHeaderData(dataRemaining, extendedHeader.size) : this.parseId3Data(this.id3Header.size - extendedHeader.size);\n    }\n    async parseExtendedHeaderData(dataRemaining, extendedHeaderSize) {\n        await this.tokenizer.ignore(dataRemaining);\n        return this.parseId3Data(this.id3Header.size - extendedHeaderSize);\n    }\n    async parseId3Data(dataLen) {\n        const uint8Array = await this.tokenizer.readToken(new Token.Uint8ArrayType(dataLen));\n        for (const tag of this.parseMetadata(uint8Array)) {\n            switch (tag.id) {\n                case 'TXXX':\n                    if (tag.value) {\n                        await this.handleTag(tag, tag.value.text, () => tag.value.description);\n                    }\n                    break;\n                default:\n                    await (Array.isArray(tag.value) ? Promise.all(tag.value.map(value => this.addTag(tag.id, value))) : this.addTag(tag.id, tag.value));\n            }\n        }\n    }\n    async handleTag(tag, values, descriptor, resolveValue = value => value) {\n        await Promise.all(values.map(value => this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, descriptor(value)), resolveValue(value))));\n    }\n    async addTag(id, value) {\n        await this.metadata.addTag(this.headerType, id, value);\n    }\n    parseMetadata(data) {\n        let offset = 0;\n        const tags = [];\n        while (true) {\n            if (offset === data.length)\n                break;\n            const frameHeaderLength = getFrameHeaderLength(this.id3Header.version.major);\n            if (offset + frameHeaderLength > data.length) {\n                this.metadata.addWarning('Illegal ID3v2 tag length');\n                break;\n            }\n            const frameHeaderBytes = data.subarray(offset, offset + frameHeaderLength);\n            offset += frameHeaderLength;\n            const frameHeader = readFrameHeader(frameHeaderBytes, this.id3Header.version.major, this.metadata);\n            const frameDataBytes = data.subarray(offset, offset + frameHeader.length);\n            offset += frameHeader.length;\n            const values = ID3v2Parser.readFrameData(frameDataBytes, frameHeader, this.id3Header.version.major, !this.options.skipCovers, this.metadata);\n            if (values) {\n                tags.push({ id: frameHeader.id, value: values });\n            }\n        }\n        return tags;\n    }\n    /**\n     * Convert parsed ID3v2 chapter frames (CHAP / CTOC) to generic `format.chapters`.\n     *\n     * This function expects the `native` tags already to contain parsed `CHAP` and `CTOC` frame values,\n     * as produced by `FrameParser.readData`.\n     */\n    static mapId3v2Chapters(id3Tags) {\n        if (!id3Tags)\n            return;\n        const chapFrames = id3Tags.filter(t => t.id === 'CHAP');\n        if (!chapFrames?.length)\n            return;\n        const tocFrames = id3Tags.filter(t => t.id === 'CTOC');\n        const topLevelToc = tocFrames?.find(t => t.value.flags?.topLevel);\n        const chapterById = new Map();\n        for (const chap of chapFrames) {\n            chapterById.set(chap.value.label, chap.value);\n        }\n        const orderedIds = topLevelToc?.value.childElementIds;\n        const chapters = [];\n        const source = orderedIds ?? [...chapterById.keys()];\n        for (const id of source) {\n            const chap = chapterById.get(id);\n            if (!chap)\n                continue;\n            const frames = chap.frames;\n            const title = frames.get('TIT2');\n            if (!title)\n                continue; // title is required\n            chapters.push({\n                id,\n                title,\n                url: frames.get('WXXX'),\n                start: chap.info.startTime / 1000,\n                end: chap.info.endTime / 1000,\n                image: frames.get('APIC')\n            });\n        }\n        // If no ordered CTOC, sort by time\n        if (!orderedIds) {\n            chapters.sort((a, b) => a.start - b.start);\n        }\n        return chapters.length ? chapters : undefined;\n    }\n}\nfunction makeUnexpectedMajorVersionError(majorVer) {\n    throw new Id3v2ContentError(`Unexpected majorVer: ${majorVer}`);\n}\n"],"names":["ChapterInfo","get","buf","off","startOffset","Token","endOffset","startTime","endTime","undefined","getFrameHeaderLength","majorVer","makeUnexpectedMajorVersionError","readFrameFlags","b","status","tag_alter_preservation","util","file_alter_preservation","read_only","format","grouping_identity","compression","encryption","unsynchronisation","data_length_indicator","readFrameHeader","uint8Array","warningCollector","header","id","textDecode","subarray","length","match","addWarning","concat","parseFrameHeaderV22","UINT32SYNCSAFE","flags","parseFrameHeaderV23V24","Id3v2ContentError","debug","initDebug","defaultEnc","urlEnc","encoding","bom","parseGenreCode","code","Genres","Number","parseInt","FrameParser","constructor","major","this","readData","type","includeCovers","TextEncodingToken","offset","output","nullTerminatorLength","getNullTerminatorLength","fzero","text","trimNullPadding","error","Error","message","functionList","splitValue","map","v","origVal","genres","word","c","push","genre","parseGenre","reduce","acc","val","Array","isArray","idAndData","readIdentifierAndData","description","data","replace","pic","fixPictureMimeType","AttachedPictureType","decodeUintBE","syltHeader","SyncTextHeader","len","result","descriptor","language","contentType","timeStampFormat","syncText","readSyllables","nullStr","readNullTerminatedString","timestamp","textHeader","TextHeader","descriptorStr","textStr","ufid","owner_identifier","identifier","priv","emailStr","email","rating","counter","counterBytes","mimeTypeStr","mimeType","filenameStr","filename","descriptionStr","url","chapter","label","info","frames","Map","subFrame","subOutput","set","idEnd","topLevel","ordered","entryCount","childElementIds","i","end","childId","toc","bomSize","originalLen","valueArray","zeroIndex","txt","pictureType","toLocaleLowerCase","entries","res","names","split","tag","values","trimArray","value","trim","charCodeAt","slice","idStr","enc","startsWith","makeUnexpectedFileContentError","ID3v2Parser","tokenizer","id3Header","metadata","headerType","options","removeUnsyncBytes","buffer","readI","writeI","readFrameData","frameHeader","_frameHeader$flags","_frameHeader$flags2","frameParser","makeDescriptionTagName","parse","readToken","ID3v2Header","fileIdentifier","version","isExtendedHeader","parseExtendedHeader","parseId3Data","size","chapters","mapId3v2Chapters","native","setFormat","extendedHeader","ExtendedHeader","dataRemaining","parseExtendedHeaderData","extendedHeaderSize","ignore","dataLen","parseMetadata","handleTag","Promise","all","addTag","resolveValue","arguments","tags","frameHeaderLength","frameHeaderBytes","frameDataBytes","skipCovers","id3Tags","chapFrames","filter","t","tocFrames","topLevelToc","find","_t$value$flags","chapterById","chap","orderedIds","source","keys","title","start","image","sort","a"],"sourceRoot":""}