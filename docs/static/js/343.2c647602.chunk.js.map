{"version":3,"file":"static/js/343.2c647602.chunk.js","mappings":"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","sources":["../node_modules/music-metadata/lib/mp4/AtomToken.js","../node_modules/music-metadata/lib/mp4/Atom.js","../node_modules/music-metadata/lib/mp4/MP4Parser.js"],"sourcesContent":["import * as Token from 'token-types';\nimport initDebug from 'debug';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport * as util from '../common/Util.js';\nconst debug = initDebug('music-metadata:parser:MP4:atom');\nexport class Mp4ContentError extends makeUnexpectedFileContentError('MP4') {\n}\nexport const Header = {\n    len: 8,\n    get: (buf, off) => {\n        const length = Token.UINT32_BE.get(buf, off);\n        if (length < 0)\n            throw new Mp4ContentError('Invalid atom header length');\n        return {\n            length: BigInt(length),\n            name: new Token.StringType(4, 'latin1').get(buf, off + 4)\n        };\n    },\n    put: (buf, off, hdr) => {\n        Token.UINT32_BE.put(buf, off, Number(hdr.length));\n        return FourCcToken.put(buf, off + 4, hdr.name);\n    }\n};\n/**\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap1/qtff1.html#//apple_ref/doc/uid/TP40000939-CH203-38190\n */\nexport const ExtendedSize = Token.UINT64_BE;\nexport const ftyp = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            type: new Token.StringType(4, 'ascii').get(buf, off)\n        };\n    }\n};\n/**\n * Token: Movie Header Atom\n */\nexport const mhdr = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            nextItemID: Token.UINT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Base class for 'fixed' length atoms.\n * In some cases these atoms are longer then the sum of the described fields.\n * Issue: https://github.com/Borewit/music-metadata/issues/120\n */\nexport class FixedLengthAtom {\n    /**\n     *\n     * @param {number} len Length as specified in the size field\n     * @param {number} expLen Total length of sum of specified fields in the standard\n     * @param atomId Atom ID\n     */\n    constructor(len, expLen, atomId) {\n        if (len < expLen) {\n            throw new Mp4ContentError(`Atom ${atomId} expected to be ${expLen}, but specifies ${len} bytes long.`);\n        }\n        if (len > expLen) {\n            debug(`Warning: atom ${atomId} expected to be ${expLen}, but was actually ${len} bytes long.`);\n        }\n        this.len = len;\n    }\n}\n/**\n * Timestamp stored in seconds since Mac Epoch (1 January 1904)\n */\nconst SecondsSinceMacEpoch = {\n    len: 4,\n    get: (buf, off) => {\n        const secondsSinceUnixEpoch = Token.UINT32_BE.get(buf, off) - 2082844800;\n        return new Date(secondsSinceUnixEpoch * 1000);\n    }\n};\n/**\n * Token: Media Header Atom\n * Ref:\n * - https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW34\n * - https://wiki.multimedia.cx/index.php/QuickTime_container#mdhd\n */\nexport class MdhdAtom extends FixedLengthAtom {\n    constructor(len) {\n        super(len, 24, 'mdhd');\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off + 0),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\n            timeScale: Token.UINT32_BE.get(buf, off + 12),\n            duration: Token.UINT32_BE.get(buf, off + 16),\n            language: Token.UINT16_BE.get(buf, off + 20),\n            quality: Token.UINT16_BE.get(buf, off + 22)\n        };\n    }\n}\n/**\n * Token: Movie Header Atom\n */\nexport class MvhdAtom extends FixedLengthAtom {\n    constructor(len) {\n        super(len, 100, 'mvhd');\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\n            timeScale: Token.UINT32_BE.get(buf, off + 12),\n            duration: Token.UINT32_BE.get(buf, off + 16),\n            preferredRate: Token.UINT32_BE.get(buf, off + 20),\n            preferredVolume: Token.UINT16_BE.get(buf, off + 24),\n            // ignore reserver: 10 bytes\n            // ignore matrix structure: 36 bytes\n            previewTime: Token.UINT32_BE.get(buf, off + 72),\n            previewDuration: Token.UINT32_BE.get(buf, off + 76),\n            posterTime: Token.UINT32_BE.get(buf, off + 80),\n            selectionTime: Token.UINT32_BE.get(buf, off + 84),\n            selectionDuration: Token.UINT32_BE.get(buf, off + 88),\n            currentTime: Token.UINT32_BE.get(buf, off + 92),\n            nextTrackID: Token.UINT32_BE.get(buf, off + 96)\n        };\n    }\n}\n/**\n * Data Atom Structure\n */\nexport class DataAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            type: {\n                set: Token.UINT8.get(buf, off + 0),\n                type: Token.UINT24_BE.get(buf, off + 1)\n            },\n            locale: Token.UINT24_BE.get(buf, off + 4),\n            value: new Token.Uint8ArrayType(this.len - 8).get(buf, off + 8)\n        };\n    }\n}\n/**\n * Data Atom Structure\n * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW31\n */\nexport class NameAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            name: new Token.StringType(this.len - 4, 'utf-8').get(buf, off + 4)\n        };\n    }\n}\n/**\n * Track Header Atoms structure (`tkhd`)\n * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25550\n */\nexport class TrackHeaderAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\n            trackId: Token.UINT32_BE.get(buf, off + 12),\n            // reserved 4 bytes\n            duration: Token.UINT32_BE.get(buf, off + 20),\n            layer: Token.UINT16_BE.get(buf, off + 24),\n            alternateGroup: Token.UINT16_BE.get(buf, off + 26),\n            volume: Token.UINT16_BE.get(buf, off + 28) // ToDo: fixed point\n            // ToDo: add remaining fields\n        };\n    }\n}\n/**\n * Atom: Sample Description Atom ('stsd')\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691\n */\nconst stsdHeader = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            numberOfEntries: Token.UINT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Atom: Sample Description Atom ('stsd')\n * Ref: https://developer.apple.com/documentation/quicktime-file-format/sample_description_atom\n */\nclass SampleDescriptionTable {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const descrLen = this.len - 12;\n        return {\n            dataFormat: FourCcToken.get(buf, off),\n            dataReferenceIndex: Token.UINT16_BE.get(buf, off + 10),\n            description: descrLen > 0 ? new Token.Uint8ArrayType(descrLen).get(buf, off + 12) : undefined\n        };\n    }\n}\n/**\n * Atom: Sample-description Atom ('stsd')\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691\n */\nexport class StsdAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const header = stsdHeader.get(buf, off);\n        off += stsdHeader.len;\n        const table = [];\n        for (let n = 0; n < header.numberOfEntries; ++n) {\n            const size = Token.UINT32_BE.get(buf, off); // Sample description size\n            off += Token.UINT32_BE.len;\n            table.push(new SampleDescriptionTable(size - Token.UINT32_BE.len).get(buf, off));\n            off += size;\n        }\n        return {\n            header,\n            table\n        };\n    }\n}\n/**\n * Common Sound Sample Description (version & revision)\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-57317\n */\nexport const SoundSampleDescriptionVersion = {\n    len: 8,\n    get(buf, off) {\n        return {\n            version: Token.INT16_BE.get(buf, off),\n            revision: Token.INT16_BE.get(buf, off + 2),\n            vendor: Token.INT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Sound Sample Description (Version 0)\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-130736\n */\nexport const SoundSampleDescriptionV0 = {\n    len: 12,\n    get(buf, off) {\n        return {\n            numAudioChannels: Token.INT16_BE.get(buf, off + 0),\n            sampleSize: Token.INT16_BE.get(buf, off + 2),\n            compressionId: Token.INT16_BE.get(buf, off + 4),\n            packetSize: Token.INT16_BE.get(buf, off + 6),\n            sampleRate: Token.UINT16_BE.get(buf, off + 8) + Token.UINT16_BE.get(buf, off + 10) / 10000\n        };\n    }\n};\nclass SimpleTableAtom {\n    constructor(len, token) {\n        this.len = len;\n        this.token = token;\n    }\n    get(buf, off) {\n        const nrOfEntries = Token.INT32_BE.get(buf, off + 4);\n        return {\n            version: Token.INT8.get(buf, off + 0),\n            flags: Token.INT24_BE.get(buf, off + 1),\n            numberOfEntries: nrOfEntries,\n            entries: readTokenTable(buf, this.token, off + 8, this.len - 8, nrOfEntries)\n        };\n    }\n}\nexport const TimeToSampleToken = {\n    len: 8,\n    get(buf, off) {\n        return {\n            count: Token.INT32_BE.get(buf, off + 0),\n            duration: Token.INT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Time-to-sample('stts') atom.\n * Store duration information for a mediaâ€™s samples.\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25696\n */\nexport class SttsAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, TimeToSampleToken);\n    }\n}\nexport const SampleToChunkToken = {\n    len: 12,\n    get(buf, off) {\n        return {\n            firstChunk: Token.INT32_BE.get(buf, off),\n            samplesPerChunk: Token.INT32_BE.get(buf, off + 4),\n            sampleDescriptionId: Token.INT32_BE.get(buf, off + 8)\n        };\n    }\n};\n/**\n * Sample-to-Chunk ('stsc') atom interface\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25706\n */\nexport class StscAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, SampleToChunkToken);\n    }\n}\n/**\n * Sample-size ('stsz') atom\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25710\n */\nexport class StszAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const nrOfEntries = Token.INT32_BE.get(buf, off + 8);\n        return {\n            version: Token.INT8.get(buf, off),\n            flags: Token.INT24_BE.get(buf, off + 1),\n            sampleSize: Token.INT32_BE.get(buf, off + 4),\n            numberOfEntries: nrOfEntries,\n            entries: readTokenTable(buf, Token.INT32_BE, off + 12, this.len - 12, nrOfEntries)\n        };\n    }\n}\n/**\n * Chunk offset atom, 'stco'\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25715\n */\nexport class StcoAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, Token.INT32_BE);\n        this.len = len;\n    }\n}\n/**\n * Token used to decode text-track from 'mdat' atom (raw data stream)\n */\nexport class ChapterText {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const titleLen = Token.INT16_BE.get(buf, off + 0);\n        const str = new Token.StringType(titleLen, 'utf-8');\n        return str.get(buf, off + 2);\n    }\n}\nfunction readTokenTable(buf, token, off, remainingLen, numberOfEntries) {\n    debug(`remainingLen=${remainingLen}, numberOfEntries=${numberOfEntries} * token-len=${token.len}`);\n    if (remainingLen === 0)\n        return [];\n    if (remainingLen !== numberOfEntries * token.len)\n        throw new Mp4ContentError('mismatch number-of-entries with remaining atom-length');\n    const entries = [];\n    // parse offset-table\n    for (let n = 0; n < numberOfEntries; ++n) {\n        entries.push(token.get(buf, off));\n        off += token.len;\n    }\n    return entries;\n}\n/**\n * Sample-size ('tfhd') TrackFragmentHeaderBox\n */\nexport class TrackFragmentHeaderBox {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const flagOffset = off + 1;\n        const header = {\n            version: Token.INT8.get(buf, off),\n            flags: {\n                baseDataOffsetPresent: util.getBit(buf, flagOffset + 2, 0),\n                sampleDescriptionIndexPresent: util.getBit(buf, flagOffset + 2, 1),\n                defaultSampleDurationPresent: util.getBit(buf, flagOffset + 2, 3),\n                defaultSampleSizePresent: util.getBit(buf, flagOffset + 2, 4),\n                defaultSampleFlagsPresent: util.getBit(buf, flagOffset + 2, 5),\n                defaultDurationIsEmpty: util.getBit(buf, flagOffset, 0),\n                defaultBaseIsMoof: util.getBit(buf, flagOffset, 1)\n            },\n            trackId: Token.UINT32_BE.get(buf, 4)\n        };\n        let dynOffset = 8;\n        if (header.flags.baseDataOffsetPresent) {\n            header.baseDataOffset = Token.UINT64_BE.get(buf, dynOffset);\n            dynOffset += 8;\n        }\n        if (header.flags.sampleDescriptionIndexPresent) {\n            header.sampleDescriptionIndex = Token.UINT32_BE.get(buf, dynOffset);\n            dynOffset += 4;\n        }\n        if (header.flags.defaultSampleDurationPresent) {\n            header.defaultSampleDuration = Token.UINT32_BE.get(buf, dynOffset);\n            dynOffset += 4;\n        }\n        if (header.flags.defaultSampleSizePresent) {\n            header.defaultSampleSize = Token.UINT32_BE.get(buf, dynOffset);\n            dynOffset += 4;\n        }\n        if (header.flags.defaultSampleFlagsPresent) {\n            header.defaultSampleFlags = Token.UINT32_BE.get(buf, dynOffset);\n        }\n        return header;\n    }\n}\n/**\n * Sample-size ('trun') TrackRunBox\n */\nexport class TrackRunBox {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const flagOffset = off + 1;\n        const trun = {\n            version: Token.INT8.get(buf, off),\n            flags: {\n                dataOffsetPresent: util.getBit(buf, flagOffset + 2, 0),\n                firstSampleFlagsPresent: util.getBit(buf, flagOffset + 2, 2),\n                sampleDurationPresent: util.getBit(buf, flagOffset + 1, 0),\n                sampleSizePresent: util.getBit(buf, flagOffset + 1, 1),\n                sampleFlagsPresent: util.getBit(buf, flagOffset + 1, 2),\n                sampleCompositionTimeOffsetsPresent: util.getBit(buf, flagOffset + 1, 3)\n            },\n            sampleCount: Token.UINT32_BE.get(buf, off + 4),\n            samples: []\n        };\n        let dynOffset = off + 8;\n        if (trun.flags.dataOffsetPresent) {\n            trun.dataOffset = Token.UINT32_BE.get(buf, dynOffset);\n            dynOffset += 4;\n        }\n        if (trun.flags.firstSampleFlagsPresent) {\n            trun.firstSampleFlags = Token.UINT32_BE.get(buf, dynOffset);\n            dynOffset += 4;\n        }\n        for (let n = 0; n < trun.sampleCount; ++n) {\n            if (dynOffset >= this.len) {\n                debug(\"TrackRunBox size mismatch\");\n                break;\n            }\n            const sample = {};\n            if (trun.flags.sampleDurationPresent) {\n                sample.sampleDuration = Token.UINT32_BE.get(buf, dynOffset);\n                dynOffset += 4;\n            }\n            if (trun.flags.sampleSizePresent) {\n                sample.sampleSize = Token.UINT32_BE.get(buf, dynOffset);\n                dynOffset += 4;\n            }\n            if (trun.flags.sampleFlagsPresent) {\n                sample.sampleFlags = Token.UINT32_BE.get(buf, dynOffset);\n                dynOffset += 4;\n            }\n            if (trun.flags.sampleCompositionTimeOffsetsPresent) {\n                sample.sampleCompositionTimeOffset = Token.UINT32_BE.get(buf, dynOffset);\n                dynOffset += 4;\n            }\n            trun.samples.push(sample);\n        }\n        return trun;\n    }\n}\n/**\n * HandlerBox (`hdlr`)\n */\nexport class HandlerBox {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const _flagOffset = off + 1;\n        const charTypeToken = new Token.StringType(4, 'utf-8');\n        return {\n            version: Token.INT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            componentType: charTypeToken.get(buf, off + 4),\n            handlerType: charTypeToken.get(buf, off + 8),\n            componentName: new Token.StringType(this.len - 28, 'utf-8').get(buf, off + 28),\n        };\n    }\n}\n/**\n * Chapter Track Reference Box (`chap`)\n */\nexport class ChapterTrackReferenceBox {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        let dynOffset = 0;\n        const trackIds = [];\n        while (dynOffset < this.len) {\n            trackIds.push(Token.UINT32_BE.get(buf, off + dynOffset));\n            dynOffset += 4;\n        }\n        return trackIds;\n    }\n}\n","import initDebug from 'debug';\nimport * as AtomToken from './AtomToken.js';\nimport { Header } from './AtomToken.js';\nconst debug = initDebug('music-metadata:parser:MP4:Atom');\nexport class Atom {\n    static async readAtom(tokenizer, dataHandler, parent, remaining) {\n        // Parse atom header\n        const offset = tokenizer.position;\n        debug(`Reading next token on offset=${offset}...`); //  buf.toString('ascii')\n        const header = await tokenizer.readToken(AtomToken.Header);\n        const extended = header.length === 1n;\n        if (extended) {\n            header.length = await tokenizer.readToken(AtomToken.ExtendedSize);\n        }\n        const atomBean = new Atom(header, extended, parent);\n        const payloadLength = atomBean.getPayloadLength(remaining);\n        debug(`parse atom name=${atomBean.atomPath}, extended=${atomBean.extended}, offset=${offset}, len=${atomBean.header.length}`); //  buf.toString('ascii')\n        await atomBean.readData(tokenizer, dataHandler, payloadLength);\n        return atomBean;\n    }\n    constructor(header, extended, parent) {\n        this.header = header;\n        this.extended = extended;\n        this.parent = parent;\n        this.children = [];\n        this.atomPath = (this.parent ? `${this.parent.atomPath}.` : '') + this.header.name;\n    }\n    getHeaderLength() {\n        return this.extended ? 16 : 8;\n    }\n    getPayloadLength(remaining) {\n        return (this.header.length === 0n ? remaining : Number(this.header.length)) - this.getHeaderLength();\n    }\n    async readAtoms(tokenizer, dataHandler, size) {\n        while (size > 0) {\n            const atomBean = await Atom.readAtom(tokenizer, dataHandler, this, size);\n            this.children.push(atomBean);\n            size -= atomBean.header.length === 0n ? size : Number(atomBean.header.length);\n        }\n    }\n    async readData(tokenizer, dataHandler, remaining) {\n        switch (this.header.name) {\n            // \"Container\" atoms, contains nested atoms\n            case 'moov': // The Movie Atom: contains other atoms\n            case 'udta': // User defined atom\n            case 'mdia': // Media atom\n            case 'minf': // Media Information Atom\n            case 'stbl': // The Sample Table Atom\n            case '<id>':\n            case 'ilst':\n            case 'tref':\n            case 'moof':\n                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining));\n            case 'meta': { // Metadata Atom, ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n                // meta has 4 bytes of padding, ignore\n                const peekHeader = await tokenizer.peekToken(Header);\n                const paddingLength = peekHeader.name === 'hdlr' ? 0 : 4;\n                await tokenizer.ignore(paddingLength);\n                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining) - paddingLength);\n            }\n            default:\n                return dataHandler(this, remaining);\n        }\n    }\n}\n","import initDebug from 'debug';\nimport * as Token from 'token-types';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { Genres } from '../id3v1/ID3v1Parser.js';\nimport { Atom } from './Atom.js';\nimport * as AtomToken from './AtomToken.js';\nimport { ChapterTrackReferenceBox, Mp4ContentError } from './AtomToken.js';\nimport { TrackType } from '../type.js';\nimport { uint8ArrayToHex } from 'uint8array-extras';\nimport { textDecode } from '@borewit/text-codec';\nconst debug = initDebug('music-metadata:parser:MP4');\nconst tagFormat = 'iTunes';\nconst encoderDict = {\n    raw: {\n        lossy: false,\n        format: 'raw'\n    },\n    MAC3: {\n        lossy: true,\n        format: 'MACE 3:1'\n    },\n    MAC6: {\n        lossy: true,\n        format: 'MACE 6:1'\n    },\n    ima4: {\n        lossy: true,\n        format: 'IMA 4:1'\n    },\n    ulaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    alaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    Qclp: {\n        lossy: true,\n        format: 'QUALCOMM PureVoice'\n    },\n    '.mp3': {\n        lossy: true,\n        format: 'MPEG-1 layer 3'\n    },\n    alac: {\n        lossy: false,\n        format: 'ALAC'\n    },\n    'ac-3': {\n        lossy: true,\n        format: 'AC-3'\n    },\n    mp4a: {\n        lossy: true,\n        format: 'MPEG-4/AAC'\n    },\n    mp4s: {\n        lossy: true,\n        format: 'MP4S'\n    },\n    // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\n    c608: {\n        lossy: true,\n        format: 'CEA-608'\n    },\n    c708: {\n        lossy: true,\n        format: 'CEA-708'\n    }\n};\nfunction distinct(value, index, self) {\n    return self.indexOf(value) === index;\n}\n/*\n * Parser for the MP4 (MPEG-4 Part 14) container format\n * Standard: ISO/IEC 14496-14\n * supporting:\n * - QuickTime container\n * - MP4 File Format\n * - 3GPP file format\n * - 3GPP2 file format\n *\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\n * Support for Apple iTunes tags as found in a M4A/M4V files.\n * Ref:\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\n */\nexport class MP4Parser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.tracks = new Map();\n        this.hasVideoTrack = false;\n        this.hasAudioTrack = true;\n        this.atomParsers = {\n            /**\n             * Parse movie header (mvhd) atom\n             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\n             */\n            mvhd: async (len) => {\n                const mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));\n                this.metadata.setFormat('creationTime', mvhd.creationTime);\n                this.metadata.setFormat('modificationTime', mvhd.modificationTime);\n            },\n            chap: async (len) => {\n                const td = this.getTrackDescription();\n                const trackIds = [];\n                while (len >= Token.UINT32_BE.len) {\n                    trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\n                    len -= Token.UINT32_BE.len;\n                }\n                td.chapterList = trackIds;\n            },\n            /**\n             * Parse mdat atom.\n             * Will scan for chapters\n             */\n            mdat: async (len) => {\n                if (this.options.includeChapters) {\n                    const trackWithChapters = [...this.tracks.values()].filter(track => track.chapterList);\n                    if (trackWithChapters.length === 1) {\n                        const chapterTrackIds = trackWithChapters[0].chapterList;\n                        const chapterTracks = [...this.tracks.values()].filter(track => chapterTrackIds.indexOf(track.header.trackId) !== -1);\n                        if (chapterTracks.length === 1) {\n                            return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\n                        }\n                    }\n                }\n                await this.tokenizer.ignore(len);\n            },\n            ftyp: async (len) => {\n                const types = [];\n                while (len > 0) {\n                    const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\n                    len -= AtomToken.ftyp.len;\n                    const value = ftype.type.replace(/\\W/g, '');\n                    if (value.length > 0) {\n                        types.push(value); // unshift for backward compatibility\n                    }\n                }\n                debug(`ftyp: ${types.join('/')}`);\n                const x = types.filter(distinct).join('/');\n                this.metadata.setFormat('container', x);\n            },\n            /**\n             * Parse sample description atom\n             */\n            stsd: async (len) => {\n                const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\n                const trackDescription = this.getTrackDescription();\n                trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n            },\n            /**\n             * Parse sample-sizes atom ('stsz')\n             */\n            stsz: async (len) => {\n                const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\n                const td = this.getTrackDescription();\n                td.sampleSize = stsz.sampleSize;\n                td.sampleSizeTable = stsz.entries;\n            },\n            date: async (len) => {\n                const date = await this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));\n                await this.addTag('date', date);\n            }\n        };\n    }\n    static read_BE_Integer(array, signed) {\n        const integerType = (signed ? 'INT' : 'UINT') + array.length * 8 + (array.length > 1 ? '_BE' : '');\n        const token = Token[integerType];\n        if (!token) {\n            throw new Mp4ContentError(`Token for integer type not found: \"${integerType}\"`);\n        }\n        return Number(token.get(array, 0));\n    }\n    async parse() {\n        this.hasVideoTrack = false;\n        this.hasAudioTrack = true;\n        this.tracks.clear();\n        let remainingFileSize = this.tokenizer.fileInfo.size || 0;\n        while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\n            try {\n                const token = await this.tokenizer.peekToken(AtomToken.Header);\n                if (token.name === '\\0\\0\\0\\0') {\n                    const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\n                    debug(errMsg);\n                    this.addWarning(errMsg);\n                    break;\n                }\n            }\n            catch (error) {\n                if (error instanceof Error) {\n                    const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\n                    debug(errMsg);\n                    this.addWarning(errMsg);\n                }\n                else\n                    throw error;\n                break;\n            }\n            const rootAtom = await Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);\n            remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);\n        }\n        // Post process metadata\n        const formatList = [];\n        this.tracks.forEach(track => {\n            const trackFormats = [];\n            track.soundSampleDescription.forEach(ssd => {\n                const streamInfo = {};\n                const encoderInfo = encoderDict[ssd.dataFormat];\n                if (encoderInfo) {\n                    trackFormats.push(encoderInfo.format);\n                    streamInfo.codecName = encoderInfo.format;\n                }\n                else {\n                    streamInfo.codecName = `<${ssd.dataFormat}>`;\n                }\n                if (ssd.description) {\n                    const { description } = ssd;\n                    if (description.sampleRate > 0) {\n                        streamInfo.type = TrackType.audio;\n                        streamInfo.audio = {\n                            samplingFrequency: description.sampleRate,\n                            bitDepth: description.sampleSize,\n                            channels: description.numAudioChannels\n                        };\n                    }\n                }\n                this.metadata.addStreamInfo(streamInfo);\n            });\n            if (trackFormats.length >= 1) {\n                formatList.push(trackFormats.join('/'));\n            }\n        });\n        if (formatList.length > 0) {\n            this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\n        }\n        const audioTracks = [...this.tracks.values()].filter(track => {\n            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;\n        });\n        // Calculate duration and bitrate of audio tracks\n        for (const audioTrack of audioTracks) {\n            if (audioTrack.media.header && audioTrack.media.header.timeScale > 0) {\n                audioTrack.sampleRate = audioTrack.media.header.timeScale;\n                if (audioTrack.media.header.duration > 0) {\n                    debug('Using duration defined on audio track');\n                    audioTrack.samples = audioTrack.media.header.duration;\n                    audioTrack.duration = audioTrack.samples / audioTrack.sampleRate;\n                }\n                if (audioTrack.fragments.length > 0) {\n                    debug('Calculate duration defined in track fragments');\n                    let totalTimeUnits = 0;\n                    audioTrack.sizeInBytes = 0;\n                    for (const fragment of audioTrack.fragments) {\n                        for (const sample of fragment.trackRun.samples) {\n                            const dur = sample.sampleDuration ?? fragment.header.defaultSampleDuration ?? 0;\n                            const size = sample.sampleSize ?? fragment.header.defaultSampleSize ?? 0;\n                            if (dur === 0) {\n                                throw new Error(\"Missing sampleDuration and no defaultSampleDuration in track fragment header\");\n                            }\n                            if (size === 0) {\n                                throw new Error(\"Missing sampleSize and no defaultSampleSize in track fragment header\");\n                            }\n                            totalTimeUnits += dur;\n                            audioTrack.sizeInBytes += size;\n                        }\n                    }\n                    if (!audioTrack.samples) {\n                        audioTrack.samples = totalTimeUnits;\n                    }\n                    if (!audioTrack.duration) {\n                        audioTrack.duration = totalTimeUnits / audioTrack.sampleRate;\n                    }\n                }\n                else if (audioTrack.sampleSizeTable.length > 0) {\n                    audioTrack.sizeInBytes = audioTrack.sampleSizeTable.reduce((sum, n) => sum + n, 0);\n                }\n            }\n            const ssd = audioTrack.soundSampleDescription[0];\n            if (ssd.description && audioTrack.media.header) {\n                this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\n                this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\n                this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\n                if (audioTrack.media.header.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {\n                    const totalSampleSize = audioTrack.timeToSampleTable\n                        .map(ttstEntry => ttstEntry.count * ttstEntry.duration)\n                        .reduce((total, sampleSize) => total + sampleSize);\n                    audioTrack.duration = totalSampleSize / ssd.description.sampleRate;\n                }\n            }\n            const encoderInfo = encoderDict[ssd.dataFormat];\n            if (encoderInfo) {\n                this.metadata.setFormat('lossless', !encoderInfo.lossy);\n            }\n        }\n        if (audioTracks.length >= 1) {\n            const firstAudioTrack = audioTracks[0];\n            if (firstAudioTrack.duration) {\n                this.metadata.setFormat('duration', firstAudioTrack.duration);\n                if (firstAudioTrack.sizeInBytes) {\n                    this.metadata.setFormat('bitrate', 8 * firstAudioTrack.sizeInBytes / firstAudioTrack.duration);\n                }\n            }\n        }\n        this.metadata.setFormat('hasAudio', this.hasAudioTrack);\n        this.metadata.setFormat('hasVideo', this.hasVideoTrack);\n    }\n    async handleAtom(atom, remaining) {\n        if (atom.parent) {\n            switch (atom.parent.header.name) {\n                case 'ilst':\n                case '<id>':\n                    return this.parseMetadataItemData(atom);\n                case 'moov':\n                    switch (atom.header.name) {\n                        case 'trak':\n                            return this.parseTrackBox(atom);\n                        case 'udta':\n                            return this.parseTrackBox(atom);\n                    }\n                    break;\n                case 'moof':\n                    switch (atom.header.name) {\n                        case 'traf':\n                            return this.parseTrackFragmentBox(atom);\n                    }\n            }\n        }\n        // const payloadLength = atom.getPayloadLength(remaining);\n        if (this.atomParsers[atom.header.name]) {\n            return this.atomParsers[atom.header.name](remaining);\n        }\n        debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);\n        await this.tokenizer.ignore(remaining);\n    }\n    getTrackDescription() {\n        // ToDo: pick the right track, not the last track!!!!\n        const tracks = [...this.tracks.values()];\n        return tracks[tracks.length - 1];\n    }\n    async addTag(id, value) {\n        await this.metadata.addTag(tagFormat, id, value);\n    }\n    addWarning(message) {\n        debug(`Warning: ${message}`);\n        this.metadata.addWarning(message);\n    }\n    /**\n     * Parse data of Meta-item-list-atom (item of 'ilst' atom)\n     * @param metaAtom\n     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n     */\n    parseMetadataItemData(metaAtom) {\n        let tagKey = metaAtom.header.name;\n        return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {\n            const payLoadLength = child.getPayloadLength(remaining);\n            switch (child.header.name) {\n                case 'data': // value atom\n                    return this.parseValueAtom(tagKey, child);\n                case 'name': // name atom (optional)\n                case 'mean':\n                case 'rate': {\n                    const name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\n                    tagKey += `:${name.name}`;\n                    break;\n                }\n                default: {\n                    const uint8Array = await this.tokenizer.readToken(new Token.Uint8ArrayType(payLoadLength));\n                    this.addWarning(`Unsupported meta-item: ${tagKey}[${child.header.name}] => value=${uint8ArrayToHex(uint8Array)} ascii=${textDecode(uint8Array, 'ascii')}`);\n                }\n            }\n        }, metaAtom.getPayloadLength(0));\n    }\n    async parseValueAtom(tagKey, metaAtom) {\n        const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(Number(metaAtom.header.length) - AtomToken.Header.len));\n        if (dataAtom.type.set !== 0) {\n            throw new Mp4ContentError(`Unsupported type-set != 0: ${dataAtom.type.set}`);\n        }\n        // Use well-known-type table\n        // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\n        switch (dataAtom.type.type) {\n            case 0: // reserved: Reserved for use where no type needs to be indicated\n                switch (tagKey) {\n                    case 'trkn':\n                    case 'disk': {\n                        const num = Token.UINT8.get(dataAtom.value, 3);\n                        const of = Token.UINT8.get(dataAtom.value, 5);\n                        // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\n                        await this.addTag(tagKey, `${num}/${of}`);\n                        break;\n                    }\n                    case 'gnre': {\n                        const genreInt = Token.UINT8.get(dataAtom.value, 1);\n                        const genreStr = Genres[genreInt - 1];\n                        // console.log(\"  %s[data] = %s\", tagKey, genreStr);\n                        await this.addTag(tagKey, genreStr);\n                        break;\n                    }\n                    case 'rate': {\n                        const rate = textDecode(dataAtom.value, 'ascii');\n                        await this.addTag(tagKey, rate);\n                        break;\n                    }\n                    default:\n                        debug(`unknown proprietary value type for: ${metaAtom.atomPath}`);\n                }\n                break;\n            case 1: // UTF-8: Without any count or NULL terminator\n            case 18: // Unknown: Found in m4b in combination with a 'Â©gen' tag\n                await this.addTag(tagKey, textDecode(dataAtom.value));\n                break;\n            case 13: // JPEG\n                if (this.options.skipCovers)\n                    break;\n                await this.addTag(tagKey, {\n                    format: 'image/jpeg',\n                    data: Uint8Array.from(dataAtom.value)\n                });\n                break;\n            case 14: // PNG\n                if (this.options.skipCovers)\n                    break;\n                await this.addTag(tagKey, {\n                    format: 'image/png',\n                    data: Uint8Array.from(dataAtom.value)\n                });\n                break;\n            case 21: // BE Signed Integer\n                await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));\n                break;\n            case 22: // BE Unsigned Integer\n                await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));\n                break;\n            case 65: // An 8-bit signed integer\n                await this.addTag(tagKey, Token.UINT8.get(dataAtom.value, 0));\n                break;\n            case 66: // A big-endian 16-bit signed integer\n                await this.addTag(tagKey, Token.UINT16_BE.get(dataAtom.value, 0));\n                break;\n            case 67: // A big-endian 32-bit signed integer\n                await this.addTag(tagKey, Token.UINT32_BE.get(dataAtom.value, 0));\n                break;\n            default:\n                this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\n        }\n    }\n    async parseTrackBox(trakBox) {\n        // @ts-expect-error\n        const track = {\n            media: {},\n            fragments: []\n        };\n        await trakBox.readAtoms(this.tokenizer, async (child, remaining) => {\n            const payLoadLength = child.getPayloadLength(remaining);\n            switch (child.header.name) {\n                case 'chap': {\n                    const chap = await this.tokenizer.readToken(new ChapterTrackReferenceBox(remaining));\n                    track.chapterList = chap;\n                    break;\n                }\n                case 'tkhd': // TrackHeaderBox\n                    track.header = await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(payLoadLength));\n                    break;\n                case 'hdlr': // TrackHeaderBox\n                    track.handler = await this.tokenizer.readToken(new AtomToken.HandlerBox(payLoadLength));\n                    track.isAudio = () => track.handler.handlerType === 'audi' || track.handler.handlerType === 'soun';\n                    track.isVideo = () => track.handler.handlerType === 'vide';\n                    if (track.isAudio()) {\n                        this.hasAudioTrack = true;\n                    }\n                    else if (track.isVideo()) {\n                        this.hasVideoTrack = true;\n                    }\n                    break;\n                case 'mdhd': { // Parse media header (mdhd) box\n                    const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(payLoadLength));\n                    track.media.header = mdhd_data;\n                    break;\n                }\n                case 'stco': {\n                    const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(payLoadLength));\n                    track.chunkOffsetTable = stco.entries; // remember chunk offsets\n                    break;\n                }\n                case 'stsc': { // sample-to-Chunk box\n                    const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(payLoadLength));\n                    track.sampleToChunkTable = stsc.entries;\n                    break;\n                }\n                case 'stsd': { // sample description box\n                    const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(payLoadLength));\n                    track.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n                    break;\n                }\n                case 'stts': { // time-to-sample table\n                    const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(payLoadLength));\n                    track.timeToSampleTable = stts.entries;\n                    break;\n                }\n                case 'stsz': {\n                    const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(payLoadLength));\n                    track.sampleSize = stsz.sampleSize;\n                    track.sampleSizeTable = stsz.entries;\n                    break;\n                }\n                case 'dinf':\n                case 'vmhd':\n                case 'smhd':\n                    debug(`Ignoring: ${child.header.name}`);\n                    await this.tokenizer.ignore(payLoadLength);\n                    break;\n                default: {\n                    debug(`Unexpected track box: ${child.header.name}`);\n                    await this.tokenizer.ignore(payLoadLength);\n                }\n            }\n        }, trakBox.getPayloadLength(0));\n        // Register track\n        this.tracks.set(track.header.trackId, track);\n    }\n    parseTrackFragmentBox(trafBox) {\n        let tfhd;\n        return trafBox.readAtoms(this.tokenizer, async (child, remaining) => {\n            const payLoadLength = child.getPayloadLength(remaining);\n            switch (child.header.name) {\n                case 'tfhd': { // TrackFragmentHeaderBox\n                    const fragmentHeaderBox = new AtomToken.TrackFragmentHeaderBox(child.getPayloadLength(remaining));\n                    tfhd = await this.tokenizer.readToken(fragmentHeaderBox);\n                    break;\n                }\n                case 'tfdt': // TrackFragmentBaseMediaDecodeTimeBo\n                    await this.tokenizer.ignore(payLoadLength);\n                    break;\n                case 'trun': { // TrackRunBox\n                    const trackRunBox = new AtomToken.TrackRunBox(payLoadLength);\n                    const trun = await this.tokenizer.readToken(trackRunBox);\n                    if (tfhd) {\n                        const track = this.tracks.get(tfhd.trackId);\n                        track?.fragments.push({ header: tfhd, trackRun: trun });\n                    }\n                    break;\n                }\n                default: {\n                    debug(`Unexpected box: ${child.header.name}`);\n                    await this.tokenizer.ignore(payLoadLength);\n                }\n            }\n        }, trafBox.getPayloadLength(0));\n    }\n    /**\n     * @param sampleDescription\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\n     */\n    parseSoundSampleDescription(sampleDescription) {\n        const ssd = {\n            dataFormat: sampleDescription.dataFormat,\n            dataReferenceIndex: sampleDescription.dataReferenceIndex\n        };\n        let offset = 0;\n        if (sampleDescription.description) {\n            const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\n            offset += AtomToken.SoundSampleDescriptionVersion.len;\n            if (version.version === 0 || version.version === 1) {\n                // Sound Sample Description (Version 0)\n                ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\n            }\n            else {\n                debug(`Warning: sound-sample-description ${version} not implemented`);\n            }\n        }\n        return ssd;\n    }\n    async parseChapterTrack(chapterTrack, track, len) {\n        if (!chapterTrack.sampleSize) {\n            if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)\n                throw new Error('Expected equal chunk-offset-table & sample-size-table length.');\n        }\n        const chapters = [];\n        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\n            const start = chapterTrack.timeToSampleTable\n                .slice(0, i)\n                .reduce((acc, cur) => acc + cur.duration, 0);\n            const chunkOffset = chapterTrack.chunkOffsetTable[i];\n            const nextChunkLen = chunkOffset - this.tokenizer.position;\n            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\n            len -= nextChunkLen + sampleSize;\n            if (len < 0)\n                throw new Mp4ContentError('Chapter chunk exceeding token length');\n            await this.tokenizer.ignore(nextChunkLen);\n            const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\n            debug(`Chapter ${i + 1}: ${title}`);\n            const chapter = {\n                title,\n                timeScale: chapterTrack.media.header ? chapterTrack.media.header.timeScale : 0,\n                start,\n                sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\n            };\n            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${track.header.duration}`); // ToDo, use media duration if required!!!\n            chapters.push(chapter);\n        }\n        this.metadata.setFormat('chapters', chapters);\n        await this.tokenizer.ignore(len);\n    }\n    findSampleOffset(track, chapterOffset) {\n        let chunkIndex = 0;\n        while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\n            ++chunkIndex;\n        }\n        return this.getChunkDuration(chunkIndex + 1, track);\n    }\n    getChunkDuration(chunkId, track) {\n        let ttsi = 0;\n        let ttsc = track.timeToSampleTable[ttsi].count;\n        let ttsd = track.timeToSampleTable[ttsi].duration;\n        let curChunkId = 1;\n        let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n        let totalDuration = 0;\n        while (curChunkId < chunkId) {\n            const nrOfSamples = Math.min(ttsc, samplesPerChunk);\n            totalDuration += nrOfSamples * ttsd;\n            ttsc -= nrOfSamples;\n            samplesPerChunk -= nrOfSamples;\n            if (samplesPerChunk === 0) {\n                ++curChunkId;\n                samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n            }\n            else {\n                ++ttsi;\n                ttsc = track.timeToSampleTable[ttsi].count;\n                ttsd = track.timeToSampleTable[ttsi].duration;\n            }\n        }\n        return totalDuration;\n    }\n    getSamplesPerChunk(chunkId, stcTable) {\n        for (let i = 0; i < stcTable.length - 1; ++i) {\n            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\n                return stcTable[i].samplesPerChunk;\n            }\n        }\n        return stcTable[stcTable.length - 1].samplesPerChunk;\n    }\n}\n"],"names":["debug","initDebug","Mp4ContentError","makeUnexpectedFileContentError","Header","len","get","buf","off","length","Token","BigInt","name","put","hdr","Number","FourCcToken","ExtendedSize","ftyp","type","FixedLengthAtom","constructor","expLen","atomId","concat","this","SecondsSinceMacEpoch","secondsSinceUnixEpoch","Date","MdhdAtom","super","version","flags","creationTime","modificationTime","timeScale","duration","language","quality","MvhdAtom","preferredRate","preferredVolume","previewTime","previewDuration","posterTime","selectionTime","selectionDuration","currentTime","nextTrackID","DataAtom","set","locale","value","NameAtom","TrackHeaderAtom","trackId","layer","alternateGroup","volume","stsdHeader","numberOfEntries","SampleDescriptionTable","descrLen","dataFormat","dataReferenceIndex","description","undefined","StsdAtom","header","table","n","size","push","SoundSampleDescriptionVersion","revision","vendor","SoundSampleDescriptionV0","numAudioChannels","sampleSize","compressionId","packetSize","sampleRate","SimpleTableAtom","token","nrOfEntries","entries","readTokenTable","TimeToSampleToken","count","SttsAtom","SampleToChunkToken","firstChunk","samplesPerChunk","sampleDescriptionId","StscAtom","StszAtom","StcoAtom","ChapterText","titleLen","remainingLen","TrackFragmentHeaderBox","flagOffset","baseDataOffsetPresent","util","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","defaultDurationIsEmpty","defaultBaseIsMoof","dynOffset","baseDataOffset","sampleDescriptionIndex","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","TrackRunBox","trun","dataOffsetPresent","firstSampleFlagsPresent","sampleDurationPresent","sampleSizePresent","sampleFlagsPresent","sampleCompositionTimeOffsetsPresent","sampleCount","samples","dataOffset","firstSampleFlags","sample","sampleDuration","sampleFlags","sampleCompositionTimeOffset","HandlerBox","charTypeToken","componentType","handlerType","componentName","ChapterTrackReferenceBox","trackIds","Atom","readAtom","tokenizer","dataHandler","parent","remaining","offset","position","readToken","AtomToken","extended","atomBean","payloadLength","getPayloadLength","atomPath","readData","children","getHeaderLength","readAtoms","paddingLength","peekToken","ignore","encoderDict","raw","lossy","format","MAC3","MAC6","ima4","ulaw","alaw","Qclp","alac","mp4a","mp4s","c608","c708","distinct","index","self","indexOf","MP4Parser","BasicParser","arguments","tracks","Map","hasVideoTrack","hasAudioTrack","atomParsers","mvhd","async","metadata","setFormat","chap","td","getTrackDescription","readNumber","chapterList","mdat","options","includeChapters","trackWithChapters","values","filter","track","chapterTrackIds","chapterTracks","parseChapterTrack","types","ftype","replace","join","x","stsd","soundSampleDescription","map","dfEntry","parseSoundSampleDescription","stsz","sampleSizeTable","date","addTag","read_BE_Integer","array","signed","integerType","parse","clear","remainingFileSize","fileInfo","errMsg","addWarning","error","Error","message","rootAtom","atom","handleAtom","formatList","forEach","trackFormats","ssd","streamInfo","encoderInfo","codecName","TrackType","audio","samplingFrequency","bitDepth","channels","addStreamInfo","audioTracks","audioTrack","media","fragments","totalTimeUnits","sizeInBytes","fragment","trackRun","_ref","_sample$sampleDuratio","_ref2","_sample$sampleSize","dur","reduce","sum","timeToSampleTable","totalSampleSize","ttstEntry","total","firstAudioTrack","parseMetadataItemData","parseTrackBox","parseTrackFragmentBox","id","metaAtom","tagKey","child","payLoadLength","parseValueAtom","uint8Array","uint8ArrayToHex","textDecode","dataAtom","num","of","genreInt","genreStr","Genres","rate","skipCovers","data","Uint8Array","from","trakBox","handler","isAudio","isVideo","mdhd_data","stco","chunkOffsetTable","stsc","sampleToChunkTable","stts","trafBox","tfhd","fragmentHeaderBox","trackRunBox","sampleDescription","chapterTrack","chapters","i","start","slice","acc","cur","nextChunkLen","title","chapter","sampleOffset","findSampleOffset","chapterOffset","chunkIndex","getChunkDuration","chunkId","ttsi","ttsc","ttsd","curChunkId","getSamplesPerChunk","totalDuration","nrOfSamples","Math","min","stcTable"],"ignoreList":[],"sourceRoot":""}