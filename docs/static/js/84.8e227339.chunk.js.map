{"version":3,"file":"static/js/84.8e227339.chunk.js","mappings":"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","sources":["../node_modules/music-metadata/lib/flac/FlacParser.js","../node_modules/music-metadata/lib/flac/FlacToken.js","../node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js","../node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js","../node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js","../node_modules/music-metadata/lib/ogg/vorbis/VorbisStream.js"],"sourcesContent":["import initDebug from 'debug';\nimport { Uint8ArrayType } from 'token-types';\nimport { VorbisPictureToken } from '../ogg/vorbis/Vorbis.js';\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { VorbisStream } from '../ogg/vorbis/VorbisStream.js';\nimport { VorbisDecoder } from '../ogg/vorbis/VorbisDecoder.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport * as Flac from './FlacToken.js';\nconst debug = initDebug('music-metadata:parser:FLAC');\nclass FlacContentError extends makeUnexpectedFileContentError('FLAC') {\n}\nexport class FlacParser extends AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.vorbisParser = new VorbisStream(this.metadata, this.options);\n    }\n    async postId3v2Parse() {\n        const fourCC = await this.tokenizer.readToken(FourCcToken);\n        if (fourCC.toString() !== 'fLaC') {\n            throw new FlacContentError('Invalid FLAC preamble');\n        }\n        let blockHeader;\n        do {\n            // Read block header\n            blockHeader = await this.tokenizer.readToken(Flac.BlockHeader);\n            // Parse block data\n            await this.parseDataBlock(blockHeader);\n        } while (!blockHeader.lastBlock);\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n        }\n    }\n    async parseDataBlock(blockHeader) {\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n        switch (blockHeader.type) {\n            case Flac.BlockType.STREAMINFO:\n                return this.readBlockStreamInfo(blockHeader.length);\n            case Flac.BlockType.PADDING:\n                break;\n            case Flac.BlockType.APPLICATION:\n                break;\n            case Flac.BlockType.SEEKTABLE:\n                break;\n            case Flac.BlockType.VORBIS_COMMENT:\n                return this.readComment(blockHeader.length);\n            case Flac.BlockType.CUESHEET:\n                break;\n            case Flac.BlockType.PICTURE:\n                await this.parsePicture(blockHeader.length);\n                return;\n            default:\n                this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);\n        }\n        // Ignore data block\n        return this.tokenizer.ignore(blockHeader.length).then();\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    async readBlockStreamInfo(dataLen) {\n        if (dataLen !== Flac.BlockStreamInfo.len)\n            throw new FlacContentError('Unexpected block-stream-info length');\n        const streamInfo = await this.tokenizer.readToken(Flac.BlockStreamInfo);\n        this.metadata.setFormat('container', 'FLAC');\n        this.processsStreamInfo(streamInfo);\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    processsStreamInfo(streamInfo) {\n        this.metadata.setFormat('codec', 'FLAC');\n        this.metadata.setFormat('hasAudio', true);\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n        if (streamInfo.totalSamples > 0) {\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n        }\n    }\n    /**\n     * Read VORBIS_COMMENT from tokenizer\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async readComment(dataLen) {\n        const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));\n        return this.parseComment(data);\n    }\n    /**\n     * Parse VORBIS_COMMENT\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async parseComment(data) {\n        const decoder = new VorbisDecoder(data, 0);\n        const vendor = decoder.readStringUtf8();\n        if (vendor.length > 0) {\n            this.metadata.setFormat('tool', vendor);\n        }\n        const commentListLength = decoder.readInt32();\n        const tags = new Array(commentListLength);\n        for (let i = 0; i < commentListLength; i++) {\n            tags[i] = decoder.parseUserComment();\n        }\n        await Promise.all(tags.map(tag => {\n            if (tag.key === 'ENCODER') {\n                this.metadata.setFormat('tool', tag.value);\n            }\n            return this.addTag(tag.key, tag.value);\n        }));\n    }\n    async parsePicture(dataLen) {\n        if (this.options.skipCovers) {\n            return this.tokenizer.ignore(dataLen);\n        }\n        return this.addPictureTag(await this.tokenizer.readToken(new VorbisPictureToken(dataLen)));\n    }\n    addPictureTag(picture) {\n        return this.addTag('METADATA_BLOCK_PICTURE', picture);\n    }\n    addTag(id, value) {\n        return this.vorbisParser.addTag(id, value);\n    }\n}\n","import * as util from '../common/Util.js';\nimport { UINT16_BE, UINT24_BE, Uint8ArrayType } from 'token-types';\n/**\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\n * ref: https://xiph.org/flac/format.html#metadata_block\n */\nexport const BlockType = {\n    STREAMINFO: 0, // STREAMINFO\n    PADDING: 1, // PADDING\n    APPLICATION: 2, // APPLICATION\n    SEEKTABLE: 3, // SEEKTABLE\n    VORBIS_COMMENT: 4, // VORBIS_COMMENT\n    CUESHEET: 5, // CUESHEET\n    PICTURE: 6 // PICTURE\n};\nexport const BlockHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            lastBlock: util.getBit(buf, off, 7),\n            type: util.getBitAllignedNumber(buf, off, 1, 7),\n            length: UINT24_BE.get(buf, off + 1)\n        };\n    }\n};\n/**\n * METADATA_BLOCK_DATA\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\n */\nexport const BlockStreamInfo = {\n    len: 34,\n    get: (buf, off) => {\n        return {\n            // The minimum block size (in samples) used in the stream.\n            minimumBlockSize: UINT16_BE.get(buf, off),\n            // The maximum block size (in samples) used in the stream.\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n            maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1000,\n            // The minimum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            minimumFrameSize: UINT24_BE.get(buf, off + 4),\n            // The maximum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            maximumFrameSize: UINT24_BE.get(buf, off + 7),\n            // Sample rate in Hz. Though 20 bits are available,\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n            // Also, a value of 0 is invalid.\n            sampleRate: UINT24_BE.get(buf, off + 10) >> 4,\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\n            channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n            // bits per sample)-1.\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n            bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n            // Total samples in stream.\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n            // A value of zero here means the number of total samples is unknown.\n            totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n            fileMD5: new Uint8ArrayType(16).get(buf, off + 18)\n        };\n    }\n};\n","import { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport { ID3v2Header } from './ID3v2Token.js';\nimport { ID3v2Parser } from './ID3v2Parser.js';\nimport { ID3v1Parser } from '../id3v1/ID3v1Parser.js';\nimport { BasicParser } from '../common/BasicParser.js';\nconst debug = initDebug('music-metadata:parser:ID3');\n/**\n * Abstract parser which tries take ID3v2 and ID3v1 headers.\n */\nexport class AbstractID3Parser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.id3parser = new ID3v2Parser();\n    }\n    static async startsWithID3v2Header(tokenizer) {\n        return (await tokenizer.peekToken(ID3v2Header)).fileIdentifier === 'ID3';\n    }\n    async parse() {\n        try {\n            await this.parseID3v2();\n        }\n        catch (err) {\n            if (err instanceof EndOfStreamError) {\n                debug(\"End-of-stream\");\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    finalize() {\n        return;\n    }\n    async parseID3v2() {\n        await this.tryReadId3v2Headers();\n        debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);\n        await this.postId3v2Parse();\n        if (this.options.skipPostHeaders && this.metadata.hasAny()) {\n            this.finalize();\n        }\n        else {\n            const id3v1parser = new ID3v1Parser(this.metadata, this.tokenizer, this.options);\n            await id3v1parser.parse();\n            this.finalize();\n        }\n    }\n    async tryReadId3v2Headers() {\n        const id3Header = await this.tokenizer.peekToken(ID3v2Header);\n        if (id3Header.fileIdentifier === 'ID3') {\n            debug('Found ID3v2 header, pos=%s', this.tokenizer.position);\n            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);\n            return this.tryReadId3v2Headers();\n        }\n    }\n}\n","import * as Token from 'token-types';\nimport { AttachedPictureType } from '../../id3v2/ID3v2Token.js';\n/**\n * Parse the METADATA_BLOCK_PICTURE\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\n * // ToDo: move to ID3 / APIC?\n */\nexport class VorbisPictureToken {\n    static fromBase64(base64str) {\n        return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), c => c.charCodeAt(0)));\n    }\n    static fromBuffer(buffer) {\n        const pic = new VorbisPictureToken(buffer.length);\n        return pic.get(buffer, 0);\n    }\n    constructor(len) {\n        this.len = len;\n    }\n    get(buffer, offset) {\n        const type = AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];\n        offset += 4;\n        const mimeLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const format = new Token.StringType(mimeLen, 'utf-8').get(buffer, offset);\n        offset += mimeLen;\n        const descLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const description = new Token.StringType(descLen, 'utf-8').get(buffer, offset);\n        offset += descLen;\n        const width = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const height = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const colour_depth = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const indexed_color = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const picDataLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const data = buffer.slice(offset, offset + picDataLen);\n        return {\n            type,\n            format,\n            description,\n            width,\n            height,\n            colour_depth,\n            indexed_color,\n            data\n        };\n    }\n}\n/**\n * Comment header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\n */\nexport const CommonHeader = {\n    len: 7,\n    get: (buf, off) => {\n        return {\n            packetType: Token.UINT8.get(buf, off),\n            vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)\n        };\n    }\n};\n/**\n * Identification header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\n */\nexport const IdentificationHeader = {\n    len: 23,\n    get: (uint8Array, off) => {\n        return {\n            version: Token.UINT32_LE.get(uint8Array, off + 0),\n            channelMode: Token.UINT8.get(uint8Array, off + 4),\n            sampleRate: Token.UINT32_LE.get(uint8Array, off + 5),\n            bitrateMax: Token.UINT32_LE.get(uint8Array, off + 9),\n            bitrateNominal: Token.UINT32_LE.get(uint8Array, off + 13),\n            bitrateMin: Token.UINT32_LE.get(uint8Array, off + 17)\n        };\n    }\n};\n","import * as Token from 'token-types';\nimport { textDecode } from '@borewit/text-codec';\nexport class VorbisDecoder {\n    constructor(data, offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n    readInt32() {\n        const value = Token.UINT32_LE.get(this.data, this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readStringUtf8() {\n        const len = this.readInt32();\n        const value = textDecode(this.data.subarray(this.offset, this.offset + len), 'utf-8');\n        this.offset += len;\n        return value;\n    }\n    parseUserComment() {\n        const offset0 = this.offset;\n        const v = this.readStringUtf8();\n        const idx = v.indexOf('=');\n        return {\n            key: v.substring(0, idx).toUpperCase(),\n            value: v.substring(idx + 1),\n            len: this.offset - offset0\n        };\n    }\n}\n","import * as Token from 'token-types';\nimport debugInit from 'debug';\nimport { VorbisDecoder } from './VorbisDecoder.js';\nimport { CommonHeader, IdentificationHeader, VorbisPictureToken } from './Vorbis.js';\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\nconst debug = debugInit('music-metadata:parser:ogg:vorbis1');\nexport class VorbisContentError extends makeUnexpectedFileContentError('Vorbis') {\n}\n/**\n * Vorbis 1 Parser.\n * Used by OggStream\n */\nexport class VorbisStream {\n    constructor(metadata, options) {\n        this.pageSegments = [];\n        this.durationOnLastPage = true;\n        this.metadata = metadata;\n        this.options = options;\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        this.lastPageHeader = header;\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n        else {\n            if (header.headerType.continued) {\n                if (this.pageSegments.length === 0) {\n                    throw new VorbisContentError('Cannot continue on previous page');\n                }\n                this.pageSegments.push(pageData);\n            }\n            if (header.headerType.lastPage || !header.headerType.continued) {\n                // Flush page segments\n                if (this.pageSegments.length > 0) {\n                    const fullPage = VorbisStream.mergeUint8Arrays(this.pageSegments);\n                    await this.parseFullPage(fullPage);\n                }\n                // Reset page segments\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n            }\n        }\n    }\n    static mergeUint8Arrays(arrays) {\n        const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);\n        const merged = new Uint8Array(totalSize);\n        arrays.forEach((array, i, _arrays) => {\n            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);\n            merged.set(array, offset);\n        });\n        return merged;\n    }\n    async flush() {\n        await this.parseFullPage(VorbisStream.mergeUint8Arrays(this.pageSegments));\n    }\n    async parseUserComment(pageData, offset) {\n        const decoder = new VorbisDecoder(pageData, offset);\n        const tag = decoder.parseUserComment();\n        await this.addTag(tag.key, tag.value);\n        return tag.len;\n    }\n    async addTag(id, value) {\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\n            if (this.options.skipCovers) {\n                debug(\"Ignore picture\");\n                return;\n            }\n            value = VorbisPictureToken.fromBase64(value);\n            debug(`Push picture: id=${id}, format=${value.format}`);\n        }\n        else {\n            debug(`Push tag: id=${id}, value=${value}`);\n        }\n        await this.metadata.addTag('vorbis', id, value);\n    }\n    calculateDuration(_enfOfStream) {\n        if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            this.metadata.setFormat('numberOfSamples', this.lastPageHeader.absoluteGranulePosition);\n            this.metadata.setFormat('duration', this.lastPageHeader.absoluteGranulePosition / this.metadata.format.sampleRate);\n        }\n    }\n    /**\n     * Parse first Ogg/Vorbis page\n     * @param _header\n     * @param pageData\n     */\n    parseFirstPage(_header, pageData) {\n        this.metadata.setFormat('codec', 'Vorbis I');\n        this.metadata.setFormat('hasAudio', true);\n        debug('Parse first page');\n        // Parse  Vorbis common header\n        const commonHeader = CommonHeader.get(pageData, 0);\n        if (commonHeader.vorbis !== 'vorbis')\n            throw new VorbisContentError('Metadata does not look like Vorbis');\n        if (commonHeader.packetType === 1) {\n            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n            debug('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n        }\n        else\n            throw new VorbisContentError('First Ogg page should be type 1: the identification header');\n    }\n    async parseFullPage(pageData) {\n        // New page\n        const commonHeader = CommonHeader.get(pageData, 0);\n        debug('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);\n        switch (commonHeader.packetType) {\n            case 3: //  type 3: comment header\n                return this.parseUserCommentList(pageData, CommonHeader.len);\n            case 1: // type 1: the identification header\n            case 5: // type 5: setup header type\n                break; // ignore\n        }\n    }\n    /**\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n     */\n    async parseUserCommentList(pageData, offset) {\n        const strLen = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n        offset += strLen;\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        while (userCommentListLength-- > 0) {\n            offset += (await this.parseUserComment(pageData, offset));\n        }\n    }\n}\n"],"names":["debug","initDebug","FlacContentError","makeUnexpectedFileContentError","FlacParser","AbstractID3Parser","constructor","super","arguments","this","vorbisParser","VorbisStream","metadata","options","postId3v2Parse","tokenizer","readToken","FourCcToken","toString","blockHeader","Flac","parseDataBlock","lastBlock","fileInfo","size","format","duration","dataSize","position","setFormat","concat","type","length","STREAMINFO","readBlockStreamInfo","PADDING","APPLICATION","SEEKTABLE","VORBIS_COMMENT","readComment","CUESHEET","PICTURE","parsePicture","addWarning","ignore","then","dataLen","len","streamInfo","processsStreamInfo","channels","bitsPerSample","sampleRate","totalSamples","data","Uint8ArrayType","parseComment","decoder","VorbisDecoder","vendor","readStringUtf8","commentListLength","readInt32","tags","Array","i","parseUserComment","Promise","all","map","tag","key","value","addTag","skipCovers","addPictureTag","VorbisPictureToken","picture","id","BlockType","BlockHeader","get","buf","off","util","UINT24_BE","BlockStreamInfo","minimumBlockSize","UINT16_BE","maximumBlockSize","minimumFrameSize","maximumFrameSize","fileMD5","BasicParser","id3parser","ID3v2Parser","startsWithID3v2Header","peekToken","ID3v2Header","fileIdentifier","parse","parseID3v2","err","EndOfStreamError","finalize","tryReadId3v2Headers","skipPostHeaders","hasAny","id3v1parser","ID3v1Parser","fromBase64","base64str","fromBuffer","Uint8Array","from","atob","c","charCodeAt","buffer","offset","AttachedPictureType","Token","mimeLen","descLen","description","width","height","colour_depth","indexed_color","picDataLen","slice","CommonHeader","packetType","vorbis","IdentificationHeader","uint8Array","version","channelMode","bitrateMax","bitrateNominal","bitrateMin","textDecode","subarray","offset0","v","idx","indexOf","substring","toUpperCase","debugInit","VorbisContentError","pageSegments","durationOnLastPage","parsePage","header","pageData","lastPageHeader","headerType","firstPage","parseFirstPage","continued","push","lastPage","fullPage","mergeUint8Arrays","parseFullPage","arrays","totalSize","reduce","acc","e","merged","forEach","array","_arrays","set","flush","calculateDuration","_enfOfStream","absoluteGranulePosition","_header","commonHeader","idHeader","byteLength","parseUserCommentList","strLen","userCommentListLength"],"sourceRoot":""}